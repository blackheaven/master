% LLNCStmpl.tex
% Template file to use for LLNCS papers prepared in LaTeX
%websites for more information: http://www.springer.com
%http://www.springer.com/lncs

\documentclass{llncs}
\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\lstset{breaklines=true, breakatwhitespace=true}
%Use this line instead if you want to use running heads (i.e. headers on each page):
%\documentclass[runningheads]{llncs}

\newcommand{\DF}{\emph{Data-Flow} }
\newcommand{\DFc}{\emph{Data-Flow}}
\newcommand{\DFp}{\emph{Data-Flow}. }
\newcommand{\SA}{\emph{Super-Arrow} }
\newcommand{\SAs}{\emph{Super-Arrow}s }
\newcommand{\FB}{\emph{Flow-based programming} }
\newcommand{\RP}{\emph{Reactive-based programming} }
\newcommand{\FRP}{\emph{Functional reactive programming} }
\newcommand{\Arr}{\emph{Arrow} }
\newcommand{\Arrs}{\emph{Arrow}s }


\begin{document}
\title{\DF : Devenez le \SA du rythme}

%If you're using runningheads you can add an abreviated title for the running head on odd pages using the following
%\titlerunning{abreviated title goes here}
%and an alternative title for the table of contents:
%\toctitle{table of contents title}

\subtitle{Modélisation du rythme de traitement et du changement de structure des flux dans un contexte \DF}

%For a single author
%\author{Author Name}

%For multiple authors:
\author{Gautier DI FOLCO}


%If using runnningheads you can abbreviate the author name on even pages:
%\authorrunning{abbreviated author name}
%and you can change the author name in the table of contents
%\tocauthor{enhanced author name}

%For a single institute
%\institute{Institute Name \email{email address}}

% If authors are from different institutes 
\institute{INRIA, équipe DICE, \email{gdifolco@ens-lyon.fr}}

%to remove your email just remove '\email{email address}'
% you can also remove the thanks footnote by removing '\thanks{Thank you to...}'


\maketitle

\begin{abstract}
Le \DF est un outil de programmation permettant d'exprimer des flux de
données circulant entre des entités d'exécutions.

Après avoir présenté ses usages et ses enjeux, nous montrons, à l'aide d'un
cas pratique, une faiblesse dans le modèle actuel qui réside dans la difficulté
de composer des contextes de calculs différents.
Nous fournissons une généralisation des \Arrs en théorie des catégories pour
renforcer le modèle.
\end{abstract}

\section{Introduction}
Le \DF modélise le "continu" dans les programmes informatiques.
Ce qui permet par exemple de décrire des animations graphiques sous l'aspect de
formules mathématiques sans gérer la manière dont elles seront interprêtées.
Les formules étant exprimmées selon des variables continues, elle seront ensuite
discrétisées pour le rendu visuelle de manière automatique.
Il en découle une notion d'infini ce qui force le calcul sur des données incomplètes
entrainnant des calculs partiel.

L'explosion du volume de données à traiter dans l'Internet est un bon cas pratique
puisque, lorsqu'on modélise un flux, il est déjà existant, donc nous n'avons pas
accès au début et le flux n'a pas de fin. Nous sommes donc obligé de produire
des résultats partiels, ce qui diminue la charge de traitement qui augmente
avec le volume croissant des données produites.

Notre objectif est de proposer des outils pour manipuler des flux ayant des
rythmes et des structures différents explicitement modélisés.

\section{Historique}
Nous exposons l'historique des langages \DF afin
de mettre en avant l'importance du rythme dans les systèmes \DFp

Strachey~\cite{Strachey73} décrit l'état du monde de la programmation
informatique, en opposant deux paradigmes : la programmation fonctionnelle et impérative.

Lorsque l'une des premières implantation du \DFc~\cite{Dennis72} est réalisée, elle
est présentée comme une généralisation de LISP, qui est un langage fonctionnel.

Le \DF est défini par Dennis et al.~\cite{Dennis72} comme un modèle dont l'exécution
est déclenchée par la disponibilité des données.
Il y a une dépendance du code vis-à-vis des données.

\subsection{Réseaux de Kahn}
Kahn~\cite{Kahn74} fournit un langage pour effectuer des calculs en parallèle,
il fait en sorte que les programmes sont articulés autour des données, plutôt que
des traitements.

Chaque partie du programme ne communique avec les autres que via des
\emph{channel}s, qui sont des listes \emph{FIFO} infinies ayant une taille de
tampon fixe.

\subsection{Prémisses de la modélisation du continu avec le \FB}
Lucid~\cite{AshcroftW76} modélise l'infini en se basant sur les suites mathématiques.

Une notion de temps a été ajouté au flux par Esterel~\cite{Berry84}.
Les programmes sont proches des filtres UNIX : ils n'ont qu'une entrée auxquels
ils réagissent sur leur sortie.

Les flux sont considéré comme un ensemble et plus comme un flux unique dans Signal~\cite{Benveniste85}.
Ce qui permet, comme dans StreamIT~\cite{Thies02}, de mettre en relation des flux
pour en créer de nouveaux.

Les programmes sont des graphes acycliques orientés, où les noeuds représentent des
algorithmes élémentaires et les arcs les dépendances sur les données, comme dans
Lustre~\cite{Caspi87}.

\subsection{L'avènement des environnements interactifs avec le \RP}
TBAG~\cite{Elliott94} introduit la notion de variation temporelle.
De manière graphique l'utilisateur va définir un ensemble de relation
entre les objects qui vont variées au cours du temps.
TBAG se charge d'évaluer ces relations à pour des valeurs temporelle
significative afin que l'animation semble avoir été calculé depuis
un flux continu.

Par la suite, MediaFlow~\cite{Elliott95} va permettre la combinaison visuelle
de flux continus.

\emph{Functional Reactive Animation} (Fran)~\cite{Elliott97}~\cite{Elliott98}
s'appuie sur une spécification programmatique des relations entre des objets
et en fonction du temps.
Il effectue ensuite de manière dynamique son rendu graphique.

Fran est le point de départ de nombreux papiers comme RT-FRP~\cite{Wan02}
qui ajoutent un aspect temps-réel où Nilsson et al.\cite{Nilsson2002a} se basent
sur la déclaration de l'enchaînement des traitements.

Le \FRP considère, comme dans André~\cite{Andre96}, les programmes comme
une réaction à un ensemble de signaux. Un signal perçu déclenche l'exécution
d'un comportement, le programme réagit à un principe de stimuli.

\subsection{Prise d'envol des besoins de traitements et perte de la vision complète des données}
La hausse du volume de données générées, échangées, traitées et stockées augmente de
plus en plus.

Notre hypothèse est que les moyens de traitement et de stockage ne sont plus
suffisant.

Nous devons mettre en place des mécanismes pour permettre de diminuer le nombre
de traitements à effectuer.

Le choix que nous avons fait est de considérer que l'information n'est pas complète.
Nous n'en possèdons pas la fin, et nous ne possédons pas souvent le début.

Ainsi, nos calculs sont effectués sur une information incomplète, ce qui nous
donne un calcul partiel.
Lorsque nous avons une nouvelle information, nous reprenons le résultat
précédemment calculé pour le compléter avec la nouvelle donnée.

Il y a une diminution du nombre de calculs, puisque ceux-ci ne sont effectués
que partiellement.

\subsubsection{Rythme et nature du flux}
Le fait d'aggréger les informations d'un flux à un autre va changer la nature
de ce flux.

La nature change car nous obtenons une donnée qui va dépendre de son historique
à paritr d'une donnée unitaire, par exemple.

Le rythme est modifié si, par exemple, le calcul est lancé uniquement toutes les
N nouvelles données, le flux de sortie aura N fois moins de message que le flux d'entrée.

\section{Modélisation du rythme et de la structure des flux}
\subsection{Cas pratique : box office}
Nous disposons d'un flux de tickets de cinéma.
Un ticket est identifié par un nom de film.

Nous souhaitons avoir un premier flux contenant une liste des films ordonnés par
nombre d'entrées décroissant.
Ce qui implique un changement de nature du flux.
Le rythme du flux ne change pas puisque la liste est mise à jour à chaque nouveau
ticket.

À partir de ce flux, nous voulons limiter le débit en le divisant par 100 pour
que la donnée puisse être affichée de manière stable.
Nous opérons un changement de rythme.

\subsection{Mise en oeuvre avec Haskell}
Haskell~\cite{Haskell10} est un langage purement fonctionnel non-strict.

Nous l'avons choisi car il est le support de nombreuses approches en \RP
et en \FRP et qu'il dispose d'un système de types assez avancé pour modéliser
notre domaine d'étude.

\subsubsection{Modélisation sans notion de rythme}
\paragraph{\emph{Arrows}}
La méthode classique pour gérer le \DF en Haskell sont les \emph{Arrows}.

Les \emph{Arrows}~\cite{Hughes00} sont une généralisation des Monades~\cite{Wadler90}.
Ils permettent de faire de la manipulation et de la composition de calculs.

Ils sont définit en Haskell via le \emph{typeclass} suivant :
\begin{lstlisting}[language=haskell]
class Control.Category.Category a => Arrow a where
    arr :: (b -> c) -> a b c
    first :: a b c -> a (b, d) (c, d)
    second :: a b c -> a (d, b) (d, c)
    (***) :: a b c -> a b' c' -> a (b, b') (c, c')
    (&&&) :: a b c -> a b c' -> a b (c, c')
\end{lstlisting}

La composition se fait via :
\begin{lstlisting}[language=haskell]
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
\end{lstlisting}

Nous modélisons la notion de noeud de calcul par un type de données
\texttt{Node}.
Il contient une fonction transformant un \texttt{a} en un \texttt{b} en fonction
de ses types paramétriques.
Nous définissons ensuite les fonctions nécessaires pour que \texttt{Node} soit
une instance du \emph{typeclass} \texttt{Arrow}.

L'implantation des noeuds \texttt{genRanking} et \texttt{stabilize} qui vont,
respectivement, mettre à jour un classement et limiter le débit d'un flux,
se fait de la façon suivante :
\begin{lstlisting}[language=haskell]
import Control.Arrow
import Control.Category
import Data.List (sortBy)
import Data.Function (on)
import Data.Maybe (catMaybes)
import Prelude hiding (id,(.))


data Node a b = Node { process :: a -> b }

instance Category Node where
    id = Node id
    (Node g) . (Node f) = Node (g . f)


instance Arrow Node where
    arr = Node
    first (Node f) = Node (\ ~(b, c) -> (f b, c))

type Ticket = String
data Rank = Rank { title :: String, visitors :: Int } deriving (Show, Eq)
type Ranking = [Rank]

genRanking :: Node (Ticket, Ranking) Ranking
genRanking = arr $ uncurry updateRanking

updateRanking :: Ticket -> Ranking -> Ranking
updateRanking t r = case b of
                        []          -> a ++ [Rank t 1]
                        (x : xs)    -> sortBy (flip compare `on` visitors) (Rank t (1 + visitors x) : a ++ xs)
    where (a, b) = break (\(Rank i _) -> i == t) r

stabilize :: Node (a, Int) (Maybe a, Int)
stabilize = arr $ \(x, i) -> if i < 2 then (Nothing, i + 1) else (Just x, 0)
\end{lstlisting}

Nous combinons ensuite ces noeuds pour n'en avoir qu'un seul, via les fonctions
de compositions disponible puisque \texttt{Node} implante le \emph{typeclass} \texttt{Arrow}.
\begin{lstlisting}[language=haskell]
stabilizedRanking :: Node ((Ticket, Ranking), Int) (Maybe Ranking, Int)
stabilizedRanking = first genRanking >>> stabilize
\end{lstlisting}

Cette implantation pose problème car elle ne permet pas de construire un classement
complet. \texttt{genRanking} voit sa sortie non-conservée si \texttt{stabilize}
produit \texttt{(Nothing, \_)}.
\texttt{genRanking} est donc limité par \texttt{stabilize}.

Nous devons donc ajouter une Monade \texttt{State} pour conserver l'état d'un exécution à l'autre.
Nous obtenons un \emph{Kielsi Arrow}~\cite{Hughes00}.
\texttt{Node} devient alors inutile puisque \texttt{Kleisli} implante déjà les
\emph{typeclass} \texttt{Arrow} et \texttt{Monad}.


\begin{lstlisting}[language=haskell]
import Control.Arrow
import Control.Category
import Data.List (sortBy)
import Data.Function (on)
import Data.Maybe (catMaybes)
import Prelude hiding (id,(.))
import Control.Monad.State

type Ticket = String
data Rank = Rank { title :: String, visitors :: Int } deriving (Show, Eq)
type Ranking = [Rank]

genRanking :: Kleisli (State Ranking) Ticket Ranking
genRanking = Kleisli $ \t -> get >>= put . updateRanking t >> get

updateRanking :: Ticket -> Ranking -> Ranking
updateRanking t r = case b of
                        []          -> a ++ [Rank t 1]
                        (x : xs)    -> sortBy (flip compare `on` visitors) (Rank t (1 + visitors x) : a ++ xs)
    where (a, b) = break (\(Rank i _) -> i == t) r

stabilize :: Kleisli (State Int) a (Maybe a)
stabilize = Kleisli $ \e -> get >>= \i ->  if i < 2
                                            then put (i + 1) >> return Nothing
                                            else put 0 >> return (Just e)
\end{lstlisting}

La composition ne peux plus se faire selon les fonctions classiques comme $>>>$
puisque les contextes, ici \texttt{Kleisli (State Ranking)} et \texttt{Kleisli (State Int)},
sont différents.

\begin{lstlisting}[language=haskell]
stabilizedRanking :: Kleisli (State (Ranking, Int)) Ticket (Maybe Ranking)
stabilizedRanking = Kleisli stabilizedRanking'

stabilizedRanking' :: Ticket -> State (Ranking, Int) (Maybe Ranking)
stabilizedRanking' e = do
    (ir, is) <- get
    let (rv, rs) = runState (runKleisli genRanking e) ir
    let (sv, ss) = runState (runKleisli stabilize rv) is
    put (rs, ss)
    return sv
\end{lstlisting}

Cette composition est coûteuse car nous devons définir nous-même la sémantique
d'évaluation qui n'est pas propre à ces deux noeuds en particulier.
Ce qui entraine une forte duplication qui ne va faire que s'accroitre de
composition en composition.
Le mécanisme ne passe pas à l'échelle puisque le tuple sera de plus en plus
grand en fonction des composition.

Ce mécanisme est adhoc est non pérein.

\begin{lstlisting}[language=haskell]
\end{lstlisting}

\paragraph{Comonad}
Comonad~\cite{Brookes91}~\cite{Coutts07}
\paragraph{Stream fusion}
Stream fusion~\cite{Yi05}

\subsubsection{Modélisation avec du rythme}

\subsection{Introduction des \SAs}

\section{Conclusion}

%The bibliography, done here without a bib file
%This is the old BibTeX style for use with llncs.cls
\bibliographystyle{splncs}

% %Alternative bibliography styles:
% %the following does the same as above except with alphabetic sorting
% %\bibliographystyle{splncs_srt}
% %the following is the current LNCS BibTex with alphabetic sorting
% %\bibliographystyle{splncs03}
% %If you want to use a different BibTex style include [oribibl] in the document class line

% \begin{thebibliography}{1}
% %add each reference in here like this:
% \bibitem[Kahn74]{Kahn74}
% Gilles Kahn:
% The Semantics of Simple Language for Parallel Programming.
% IFIP Congress, (1974) 471-475.
% \end{thebibliography}
\bibliography{LLNCStmpl}

\end{document}

