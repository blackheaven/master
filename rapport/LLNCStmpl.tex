% LLNCStmpl.tex
% Template file to use for LLNCS papers prepared in LaTeX
%websites for more information: http://www.springer.com
%http://www.springer.com/lncs

\documentclass{llncs}
\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\lstset{
  basicstyle=\small\ttfamily,
  frame=lrtb,
  numbers=left,
  breaklines=true,
  breakatwhitespace=true,
  language=haskell
}
%Use this line instead if you want to use running heads (i.e. headers on each page):
%\documentclass[runningheads]{llncs}

\newcommand{\DF}{\emph{Data-Flow} }
\newcommand{\DFc}{\emph{Data-Flow}}
\newcommand{\DFp}{\emph{Data-Flow}. }
\newcommand{\SA}{\emph{Heterogeneous-Arrow} }
\newcommand{\SAs}{\emph{Heterogeneous-Arrow}s }
\newcommand{\FB}{\emph{Flow-based programming} }
\newcommand{\RP}{\emph{Reactive-based programming} }
\newcommand{\FRP}{\emph{Functional reactive programming} }
\newcommand{\Arr}{\lstinline{Arrow} }
\newcommand{\Arrp}{\lstinline{Arrow}. }
\newcommand{\Arrs}{\lstinline{Arrow}s }
\newcommand{\Arrv}{\lstinline{Arrow}, }


\begin{document}
\title{\SA : modéliser le rythme du \DF}

%If you're using runningheads you can add an abreviated title for the running head on odd pages using the following
%\titlerunning{abreviated title goes here}
%and an alternative title for the table of contents:
%\toctitle{table of contents title}

\subtitle{Modélisation du rythme de traitement et du changement de structure des flux dans un contexte \DF}

%For a single author
%\author{Author Name}

%For multiple authors:
\author{Gautier DI FOLCO}


%If using runnningheads you can abbreviate the author name on even pages:
%\authorrunning{abbreviated author name}
%and you can change the author name in the table of contents
%\tocauthor{enhanced author name}

%For a single institute
%\institute{Institute Name \email{email address}}

% If authors are from different institutes 
\institute{INRIA, équipe DICE, \email{gdifolco@ens-lyon.fr}}

%to remove your email just remove '\email{email address}'
% you can also remove the thanks footnote by removing '\thanks{Thank you to...}'


\maketitle

\begin{abstract}
Le \DF est un outil de programmation permettant d'exprimer des flux de
données circulant entre des entités d'exécutions.

Après avoir présenté ses usages et ses enjeux, nous montrons, à l'aide d'un
cas pratique, une faiblesse dans le modèle actuel qui réside dans la difficulté
de composer des contextes de calculs différents.
Nous fournissons une généralisation des \Arrs en Haskell.
\end{abstract}

\section{Introduction}
Le \DF modélise le "continu" dans les programmes informatiques.
Ce qui permet par exemple de décrire des animations graphiques sous l'aspect de
formules mathématiques sans gérer la manière dont elles seront interprêtées.
Les formules étant exprimées selon des variables continues, elle seront ensuite
discrétisées pour le rendu visuel de manière automatiquement.
Du fait que le continu est représenté par une infinité de valeur entre deux bornes,
il en découle une notion d'infini, les bornes étant inacessibles.
Ce qui force le calcul sur des données incomplètes entrainant des calculs partiels.

Cette notion d'incomplétude des données est utilisé pour répondre à un problème
de charge de traitements.
Par exemple l'afflux de données provenant de l'Iternet a tellement augmenté qu'il
devient trop coûteux en ressources de lancer un calcul donné sur l'ensemble des
données.
De plus, lorsqu'on modélise un flux, il est déjà existant, donc nous n'avons pas
accès au début et le flux n'a pas de fin.
Ainsi des calculs partiels sont effectués et complétés au fur et à mesure de la
réception de nouvelles données.

Notre objectif est de proposer des outils pour manipuler des flux ayant des
rythmes et des structures différents explicitement modélisés.

\section{Historique}
Nous exposons l'historique des langages \DF afin
de mettre en avant l'importance du rythme dans les systèmes \DFp

Strachey~\cite{Strachey73} décrit l'état du monde de la programmation
informatique, en opposant deux paradigmes : la programmation fonctionnelle et impérative.

L'une des premières implantation du \DFc~\cite{Dennis72} réalisée
est présentée comme une généralisation de LISP, qui est un langage fonctionnel.

Le \DF est défini par Dennis et al.~\cite{Dennis72} comme un modèle dont l'exécution
est déclenchée par la disponibilité des données.
Il y a une dépendance explicitement modélisée du code vis-à-vis des données.

\subsection{Réseaux de Kahn}
Kahn~\cite{Kahn74} fournit un langage pour effectuer des calculs en parallèle,
où les programmes sont découpés en entités communiquant entre elles via des
\emph{channel}s, qui sont des listes \emph{FIFO} infinies ayant une taille de
tampon fixe.

\subsection{Prémisses de la modélisation du continu avec le \FB}
Lucid~\cite{AshcroftW76} modélise l'infini en se basant sur les suites mathématiques.
L'infini est modélisé par une valeur de départ et un code pour calculer les valeurs
suivantes.

Une notion de temps a été ajoutée au flux par Esterel~\cite{Berry84}.
Les programmes sont proches des filtres UNIX : ils n'ont qu'une entrée auxquels
ils réagissent sur leur sortie.

Les flux sont considérés comme un ensemble et plus comme un flux unique dans Signal~\cite{Benveniste85}.
Ce qui permet, comme dans StreamIT~\cite{Thies02}, de mettre en relation des flux
pour en créer de nouveaux.

Les programmes sont des graphes acycliques orientés, où les noeuds représentent des
algorithmes élémentaires et les arcs les dépendances sur les données, comme dans
Lustre~\cite{Caspi87}.

\subsection{L'avènement des environnements interactifs avec le \RP}
TBAG~\cite{Elliott94} introduit la notion de variation temporelle.
De manière graphique l'utilisateur va définir un ensemble de relations
entre les objects qui vont varier au cours du temps.
TBAG se charge d'évaluer ces relations pour des valeurs temporelles
significatives afin que l'animation semble avoir été calculée depuis
un flux continu.

Par la suite, MediaFlow~\cite{Elliott95} va permettre la combinaison visuelle
de flux continus.

\emph{Functional Reactive Animation} (Fran)~\cite{Elliott97}~\cite{Elliott98}
s'appuie sur une spécification programmatique des relations entre des objets
en fonction du temps.
Il effectue ensuite son rendu graphique dynamiquement.

Fran est le point de départ de nombreux papiers comme RT-FRP~\cite{Wan02}
qui ajoute un aspect temps-réel où Nilsson et al.\cite{Nilsson2002a} qui se base
sur la déclaration de l'enchaînement des traitements.

Le \FRP considère, comme dans André~\cite{Andre96}, les programmes comme
une réaction à un ensemble de signaux. Un signal perçu déclenche l'exécution
d'un comportement, le programme réagit à un principe de stimuli.

\subsection{Conclusion}
La hausse du volume de données générées, échangées, traitées et stockées augmente de
plus en plus.

Notre hypothèse est que les moyens de traitement et de stockage ne sont plus
suffisants.

Nous devons mettre en place des mécanismes pour permettre de diminuer la charge
de traitements à effectuer.

Le choix que nous avons fait est de considérer que l'information n'est pas complète.
Nous n'en possèdons pas la fin, et nous ne possédons pas souvent le début.

Ainsi, nos calculs sont effectués sur une information incomplète, ce qui nous
donne un calcul partiel.
Lorsque nous avons une nouvelle information, nous reprenons le résultat
précédemment calculé pour le compléter avec la nouvelle donnée.

Il y a une diminution du nombre de calculs, puisque ceux-ci ne sont effectués
que partiellement.

\subsubsection{Rythme et nature du flux}
Nous appelons nature d'un flux la méthode de construction des données sortantes.
Par exemple, le fait d'aggréger les informations d'un flux à un autre va changer
sa nature car nous obtenons une donnée qui va dépendre de son historique
à partir d'une donnée unitaire.

Le rythme est modifié si, par exemple, le calcul est lancé uniquement toutes les
N nouvelles données, le flux de sortie aura N fois moins de messages que le flux d'entrée.

\section{Modélisation du rythme et de la structure des flux}
\subsection{Cas pratique : box office}
Nous disposons d'un flux de tickets de cinéma.
Un ticket est identifié par un nom de film.

Nous souhaitons avoir un premier flux contenant une liste des films ordonnés par
nombre d'entrées décroissant.
Ce qui implique un changement de nature du flux.
Le rythme du flux ne change pas puisque la liste est mise à jour à chaque nouveau
ticket.

À partir de ce flux, nous voulons limiter le débit en le divisant par 100 pour
que la donnée puisse être affichée de manière stable.
Nous opérons un changement de rythme.

\subsection{Mise en oeuvre avec Haskell}
Haskell~\cite{Haskell10} est un langage purement fonctionnel non-strict.

Nous l'avons choisi car il est le support de nombreuses approches à la fois \RP
et en \FRP et qu'il dispose d'un système de types assez avancé pour modéliser
notre domaine d'étude.

\subsubsection{Modélisation sans notion de rythme}
\paragraph{\Arrs}
La méthode classique pour gérer le \DF en Haskell sont les \emph{Arrows}.

Les \Arrs~\cite{Hughes00} sont une spécialisation des \lstinline{Category}
qui définissent la notion de composition sous forme de \emph{typeclass}.

En Haskell un \emph{typeclass} représente une capacité à appeler un ensemble
de fonctions sur un ensemble de type de données.
Il s'agit d'un mécanisme proche des \emph{template}s spécialisées du C++.

\begin{lstlisting}
class Category cat where
  id :: cat a a
  (.) :: cat b c -> cat a b -> cat a c
\end{lstlisting}

Ici nous déclarons le \emph{typeclass} \lstinline{Category}.
Pour un type arbitraire \lstinline{cat}, deux fonctions lui sont associées.
Seul leur type sont déclarés ici, par leurs implantations.

La fonction \lstinline{id}, qui va représenter l'identité, c'est à dire
que  \lstinline{cat} aura ses deux paramètre de même type, le type \lstinline{a}.

La ligne 3 comporte un nouveau type : \lstinline{->}.
Il s'agit du type fonction.
Il est fourni par le langage.
Sa pseudo déclaration est la suivante :
\begin{lstlisting}
data i -> o = ...
\end{lstlisting}
Une fonction a un paramètre de type \lstinline{i} en entrée et retourne une
valeur de type \lstinline{o}.
Pour qu'une fonction prennent plusieurs arguments, il faut que, conceptuellement,
à chaque nouvel argument appliqué, elle retourne une nouvelle fonction.
Ainsi, les fonctions suivante ont le même type :
\begin{lstlisting}
f :: a -> b -> c -> d -> e
g :: a -> (b -> (c -> (d -> e)))
\end{lstlisting}

L'opérateur de composition \lstinline{(.)} qui va créer une \lstinline{Category}
ayant pour types paramétriques \lstinline{a c} en redirigeant la sortie d'une
\lstinline{Category} \lstinline{b c} vers l'entrée d'une \lstinline{Category} \lstinline{a b}.

On distingue deux types de fonction en Haskell : les fonctions classiques et les opérateurs.
Les fonctions classiques sont nommées avec des caractères alphanumériques et commencent
toujours par une minuscule.
Les opérateurs ne sont composés que de caractères non-alphanumériques.

La différence entre les deux est visible au niveau de la position par défaut lors
de l'appel.
Les fonctions classiques ont une position préfixe :
\begin{lstlisting}
add 4 5
\end{lstlisting}

ici, \lstinline{add} est une fonction classique, elle est donc placé devant ses
arguments.

Les opérateurs ont une position infixe :
\begin{lstlisting}
4 + 5
\end{lstlisting}

ici, \lstinline{+} est un opérateur, il est donc placé entre ses deux premiers
arguments.

Nous pouvons changer la position des fonctions classiques et des opérateurs en
les entourant, respectivement, de \emph{back-quotes} (\lstinline{`}) et de paranthèses.
Ainsi, voici l'équivalent des deux exemples précédents en inversant les positions :
\begin{lstlisting}
4 `add` 5
(+) 4 5
\end{lstlisting}

Cette distinction est importante car, lorsque nous mentionnons une fonction en position
préfixe et que nous omettons un ou plusieurs de ses dernier arguments, une fonction
est automatiquement créée.
Cette fonction aura pour paramètres, les paramètres omis.
On parle de currification ou \emph{currying} ou d'application partielle.
Comme nous l'avons vu plus haut, de manière plus général, en Haskell, toutes les
fonctions n'attendent qu'un argument et ne renvoie qu'une valeur.
Ainsi, conceptuellement, losqu'une fonction attends plusieurs arguments, lors de
chacun de ses appels, une nouvelle fonction est retournée :
\begin{lstlisting}
add :: Int -> Int -> Int
add 4 :: Int -> Int
add 4 5 :: Int
\end{lstlisting}

Le type de \lstinline{add} peut être ré-écrit de la manière suivante :
\begin{lstlisting}
add :: Int -> (Int -> Int)
\end{lstlisting}

Alors que les fonctions en position préfixes créent automatiquement des fonctions
lorsqu'elles ne sont que partiellement appliquées, si un des deux premiers arguments
manquent à un opérateur, une erreur de syntaxe est levée.
Les exemples suivants ne sont pas syntaxiquement valide :
\begin{lstlisting}
`add`
`add` 5
4 `add`
+
+ 5
4 +
\end{lstlisting}

Pour les rendres valide, il faut les entourer de paranthèses :
\begin{lstlisting}
(`add`)
(`add` 5)
(4 `add`)
(+)
(+ 5)
(4 +)
\end{lstlisting}

C'est la raison pour laquelle, lorsque l'on déclare le type d'un opérateur, comme
l'opérateur de composition \lstinline{(.)}, nous sommes obligés de le paranthèsés,
puisque nous ne lui passons aucune valeur.

Un exemple d'implantation de \lstinline{Category} est pour le type des fonctions.
Le type fonction est un type à part entère noté \lstinline{(->)}.
Ainsi, à partir de la déclaration du \emph{typeclass} \lstinline{Category}, nous
remplaçons toutes les occurences de \lstinline{cat} par \lstinline{(->)}.
\begin{lstlisting}
instance Category (->) where
-- Version prefixe : id :: (->) a a
  id :: a -> a
  id x = x

-- Version prefixe : (.) :: (->) b c -> (->) a b -> (->) a c
  (.) :: (b -> c) -> (a -> b) -> (a -> c)
  f . g = \x -> f (g x)
\end{lstlisting}

\lstinline{id}, ligne 4, attent un argument \lstinline{x} et le retourner.
Le type de \lstinline{x} est quelconque, noté \lstinline{a}, et le type de retour
de \lstinline{id} est le même que le type de son paramètre, soit \lstinline{a}.

\lstinline{(.)}, ligne 8, attent deux fonctions pour en produire une troisième.
Son premier argument, \lstinline{f}, est une fonction attendant un type quelconque
noté \lstinline{b} et renvoyant un type quelconque \lstinline{c}, le tout est
noté \lstinline{b -> c}.
Son second argument, \lstinline{g}, est une fonction attendant un type quelconque
noté \lstinline{a} et renvoyant un type quelconque \lstinline{b}, le tout est
noté \lstinline{a -> b}.
\lstinline{(.)} crée une \emph{lambda expression}, une sorte de fonction anonyme,
via \lstinline{\x ->} attendant un paramètre \lstinline{x}.
Il va appliquer ce paramètre à la fonction \lstinline{g}, via \lstinline{g x}.
Puis le résultat de cette application sera appliqué à la fonction \lstinline{f}.
Par conséquent, la fonction résultante aura un paramètre du type de celui de la
fonction \lstinline{g}, ie. \lstinline{a}, et un type de retour de sa fonction \lstinline{f},
ie. \lstinline{c}.
Donc, c'est une fonction qui prend deux fonctions, l'un prenant un \lstinline{a}
et renvoyant un \lstinline{b}, l'autre prenant un \lstinline{b} et renvoyant un \lstinline{c}.
Elle renvoie une fonction prenant un \lstinline{a} et renvoyant un \lstinline{c},
qui est bien la notion de composition.

Par exemple, si nous disposons de deux fonctions \lstinline{add3} et \lstinline{prod2},
qui, respectivement, ajoute \lstinline{3} à un nombre et le multiplie par \lstinline{2},
nous pouvons les combiner de la manière suivante :
\begin{lstlisting}
add3 :: Int -> Int
add3 x = x + 3

prod2 :: Int -> Int
prod2 x = x * 2

prod2Add3 :: Int -> Int
prod2Add3 = add3 . prod2
\end{lstlisting}

Ainsi \lstinline{prod2Add3 1} renvoie \lstinline{5}.
Nous aurions put l'ecrire \lstinline{prod2Add3 x = prod2 (add3 x)}.
En fait il se passe le mécanisme de substitution suivant :
\begin{lstlisting}
prod2Add3 = add3 . prod2
-- f . g = \x -> f (g x)
-- f est remplace par add3 et g par prod2
prod2Add3 = \x -> add3 (prod2 x)
-- lorsque 1 est applique a prod2Add3 :
prod2Add3 1
(\x -> add3 (prod2 x)) 1
-- x est remplace par 1
add3 (prod2 1)
add3 (1 * 2)
add3 2
2 + 3
5
\end{lstlisting}

Pour représenter notre cas pratique, nous modélisons la notion de noeud de calcul
par un type de données \lstinline{Node}, ligne 1.
Il contient une fonction transformant un \lstinline{a} en un \lstinline{b} en fonction
de ses types paramétriques.

Le mot clef \lstinline{data} permet de définir de nouveau types de données.
Il est suivit de l'indentifieur de type, qui commence toujours par une lettre
majuscule lorsqu'il est alphanumérique, ici \lstinline{Node}.
Il peut être ensuite suivit d'un ou plusieurs paramètres de types, ici
\lstinline{a} et \lstinline{b}.
L'identifieur de type est utilisé uniquement dans les déclaration de types.

Ensuite, après le \lstinline{=} vient le ou les constructeurs, ici \lstinline{Node}.
Ils suivent les mêmes convention de nommage que les identifieurs de types, mais
l'identifieur de type et le constructeur n'ont pas obligatoirement le même nom.
Un construteur peut attendre des valeurs ou non, ici il attend une fonction de
type \lstinline{a -> b}.
Qui plus est, nous demandons qu'un accesseur \lstinline{process} soit créé,
Ce qui permettra par la suite de ne pas utiliser le \emph{pattern matching} pour
extraire la fonction.

Nous définissons ensuite les fonctions nécessaires pour que \lstinline{Node} soit
une instance du \emph{typeclass} \lstinline{Category}, ligne 4 et 5.
Nous n'avons pas besoin d'indiquer le type des fonctions, Haskell le déduit automatiquement
via \emph{typeclass} qu'il implante.
\lstinline{id}, ligne 4, est un appel au constructeur \lstinline{Node} avec la
fonction générique \lstinline{id}.
Ainsi le type de cette fonction est \lstinline{Node a a}.

L'opérateur de composition, ligne 5, extrait, par déconstruction, filtrage par motifs
ou \emph{pattern matching}, les valeurs du constructeur de \lstinline{Node} de chacun de ses argument.
\lstinline{g} et \lstinline{f} sont deux fonctions qui sont recomposées au sein
d'un nouveau \lstinline{Node}.

\begin{lstlisting}
data Node a b = Node { process :: a -> b }

instance Category Node where
    id = Node id
    (Node g) . (Node f) = Node (g . f)
\end{lstlisting}

Ensuite viennent les types plus spécifiques à notre problème :

\begin{lstlisting}
data Rank = Rank { title :: String, visitors :: Int } deriving (Show, Eq)
type Ticket = String
type Ranking = [Rank]
\end{lstlisting}

Ici, nous définissons un type \lstinline{Rank}, ligne 1,
composé d'une chaine de caractère, \lstinline{String}, et d'un entier, \lstinline{Int}.
Nous lui ajoutons deux \emph{typeclass} qui seront automatiquement implanter par
le compilateur : \lstinline{Show}, pour pouvoir afficher les valeurs et \lstinline{Eq},
pour faire des comparaisons entre deux valeurs.
Le compilateur est en mesure de déduire les implantations naives pour un certain
nombre de \emph{typeclass}.

Puis, deux alias de types : \lstinline{Ticket} et \lstinline{Ranking} qui sont,
respectivement, les alias de \lstinline{String} et de \lstinline{[Rank]}.
Les alias ne font qu'améliorer la lisibilité des types, ils n'influent pas sur
la compilation ou l'exécution.

\lstinline{[Char]} représente une liste de \lstinline{Char}.
Il est définie de la manière suivante :
\begin{lstlisting}
data [] a = []
          | a : [a]
\end{lstlisting}

Le type liste est composé de deux constructeurs, séparés par un \lstinline{|}.
Le premier, ligne 1, \lstinline{[]}, ne prend aucun valeur et représente l'élément
liste vide.
Le second, ligne 2, est l'opérateur \lstinline{(:)}, qui attends deux arguments :
le premier est une valeur de type \lstinline{a} et le second est une autre liste de
type \lstinline{a}, noté \lstinline{[a]}.
Il s'agit d'un type récursif puisqu'un de ses constructeurs a un de ses paramètres
de son propre type.

Nous implémentons notre noeud \lstinline{stabilize} qui limite le débit d'un flux.
Pour cela nous avons besoin d'une valeur quelconque et d'un compteur en entrée,
nous utilisons un tuple \lstinline{a, Int}.
Le noued va produire une nouvelle valeur pour le compteur et peut-être une valeur,
en fonction de l'état de son compteur.

La possibilité de présence ou de l'absence d'une valeur est représenté par le type
suivant :

\begin{lstlisting}
data Maybe a = Nothing
             | Just a
\end{lstlisting}

Le constructeur \lstinline{Nothing}, ligne 1, représente l'absence de valeur.
Tandis que \lstinline{Just}, ligne 2, représente la présence d'une valeur de type
\lstinline{a} qu'il va contenir.

Nous implémentons \lstinline{stabilize} de cette manière :
\begin{lstlisting}
stabilize :: Node (a, Int) (Maybe a, Int)
stabilize = Node $ \(x, i) -> if i < 2
                             then (Nothing, i + 1)
                             else (Just x, 0)
\end{lstlisting}

Nous faisons appel au constructeur \lstinline{Node}, ligne 2, en lui fournissant
une \emph{lambda expression}.
Le \lstinline{$} est une alternative au paranthèsage jusqu'à la fin de la ligne.
Celle-ci possède un paramètre qui doit être une paire d'une valeur de type arbitraire
nommée \lstinline{x} et un entier nommé \lstinline{i}.
Si l'entier, le compteur, \lstinline{i} est inférieur à 2, nous renvoyons, ligne 3,
une paire dont le premier élément est \lstinline{Nothing}, car nous souhaitons
ne renvoyer qu'une valeur sur 3, et nous incrémentons le compteur \lstinline{i}.
Si non, ligne 4, nous renvoyons une paire contenant la valeur et nous remettons
le compteur à 0.

L'implantation des noeuds \lstinline{genRanking} qui met à jour un classement
nécessite un classement et un ticket et un classement pour générer un nouveau classement.
Comme pour \lstinline{stabilize}, \lstinline{genRanking} va attendre une paire en
entrée, comprenant un \lstinline{Ticket} et un \lstinline{Ranking} et produira
un \lstinline{Ranking}.
\begin{lstlisting}
genRanking :: Node (Ticket, Ranking) Ranking
genRanking = Node $ uncurry updateRanking
\end{lstlisting}
\lstinline{uncurry} est une fonction qui transforme une fonction attendant deux éléments
en fonction attendant une paire, elle est définie de la manière suivante :
\begin{lstlisting}
uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry f (a, b) =  f a b
\end{lstlisting}

\lstinline{updateRanking} va attendre un \lstinline{Ticket} \lstinline{t} et un
\lstinline{Ranking} \lstinline{r}.
\begin{lstlisting}
updateRanking :: Ticket -> Ranking -> Ranking
updateRanking t r = case b of
                        []          -> a ++ [Rank t 1]
                        (x : xs)    -> sortBy (flip compare `on` visitors) (Rank t (1 + visitors x) : a ++ xs)
    where (a, b) = break (\ (Rank i _) -> i == t) r
\end{lstlisting}
La fonction \lstinline{break} va être appelée à la ligne 5.
Son rôle est de, à partir d'une fonction, renvoyant un booléen en fonction d'un
élément de son second paramètre, une liste, ici les \lstinline{Rank}s \lstinline{r}.
\lstinline{break} parcourt sa liste, de gauche à droite et lorsque la fonction passé
en première argument renvoie \lstinline{True}, \lstinline{break} va générer une
paire de tableau dans lequel son premier membre sera l'ensemble des éléments déjà
parcourus et son membre de gauche sera le tableau contenant l'élement courant et
le reste de la liste.
La fonction donnée à \lstinline{break} va renvoyer \lstinline{True} lorsque le titre
du film \lstinline{i} de l'élément courant est égale au titre du film sur le
\lstinline{Ticket} \lstinline{t}.
Le résultat de \lstinline{break} est séparé en \lstinline{a} et \lstinline{b}.

Nous distinguons deux cas pour \lstinline{b}.

S'il est vide, ligne 3, \lstinline{[]}, c'est que c'est le premier \lstinline{Ticket}
pour un film.
Dans ce cas, nous ajoutons le film avec une entrée à la fin du \lstinline{Ranking}.

Si non, ligne 4, nous extrayons le premier élément de \lstinline{b} dans \lstinline{x}
et le reste de la liste dans \lstinline{xs}.
\lstinline{x} est le \lstinline{Rank} correspondant au film de notre \lstinline{Ticket}.
Nous ajoutons la première partie de la liste \lstinline{a}, au reste de la liste
\lstinline{xs} au \lstinline{Rank} incrémenté, puis nous trions le tout pour obtenir
un \lstinline{Ranking} ordonné.

Si nous souhaitons composer ces deux noeuds nous sommes dans l'incapacité de le
faire car le type de sortie de \lstinline{genRanking} n'est pas le même que le
type d'entrée de \lstinline{stabilize} :
\begin{lstlisting}
genRanking :: Node (Ticket, Ranking) Ranking
stabilize :: Node (a, Int) (Maybe a, Int)
\end{lstlisting}

Les \Arrs~\cite{Hughes00} ont été introduits pour pouvoir combiner de manière
standard des fonctions au sein d'une \lstinline{Category}.
Il s'agit d'une spécialisation des \lstinline{Category}.
Ils \Arrs sont définis en Haskell via le \emph{typeclass} suivant :
\begin{lstlisting}
class Category a => Arrow a where
    arr :: (b -> c) -> a b c
    first :: a b c -> a (b, d) (c, d)
    second :: a b c -> a (d, b) (d, c)
    (***) :: a b c -> a b' c' -> a (b, b') (c, c')
    (&&&) :: a b c -> a b c' -> a b (c, c')
\end{lstlisting}

Ici la fonction \lstinline{arr} construit un type de données
\lstinline{a b c} à partir d'une fonction \lstinline{b -> c}.
Typiquement il s'agit de stocker la fonction dans un type de données.

\lstinline{first} et \lstinline{second} changent le type d'entrée et de sortie
en tuple ayant un membre supplémentaire.
Cette valeur a un type quelconque et sera simplement recopiée lors de l'évaluation
du calcul.
Cette valeur se situe en seconde position du tuple pour \lstinline{first} et en
première position du tuple pour \lstinline{second}.

\lstinline{***} aggrége deux calculs qui seront effectués sans interaction l'un
avec l'autre.

\lstinline{&&&} crée un calcul qui applique un même argument à deux calculs ayant
le même type d'entrée et retournera ensuite leur résultat respectif dans un tuple.

De plus deux opérateurs de composition sont introduits :
\begin{lstlisting}
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
\end{lstlisting}

\lstinline{<<<} est un alias de l'opérateur de composition \lstinline{(.)}.
\lstinline{>>>} est aussi un alias mais dont les paramètres ont été inversés.

Nous définissons ensuite les fonctions nécessaires pour que \lstinline{Node} soit
une instance du \emph{typeclass} \Arrv ligne 2 et 3.
Toutes les fonctions n'ont pas besoin d'être définies car certaines d'entre-elles
disposent d'une implantation par défaut, qui repose sur d'autres fonctions du
\emph{typeclass}, dans la définition du \emph{typeclass}.

\begin{lstlisting}
instance Arrow Node where
    arr = Node
    first (Node f) = Node (\ ~(b, c) -> (f b, c))
\end{lstlisting}

\lstinline{arr}, ligne 2, se contente d'appeler le constructeur de \lstinline{Node}.
Par curryfication, cela revient à écrire \lstinline{arr x = Node x}.

\lstinline{first}, ligne 3, va extraire la fonction \lstinline{f} de \lstinline{Node}.
Il va ensuite créer un nouveau \lstinline{Node}, dont la fonction est définie par
une \emph{lambda expression}.
Celle-ci attend un tuple et va en renvoyer un dont le second membre, \lstinline{c},
sera inchangé, mais dont le premier, \lstinline{b}, se voit appliqué à la fonction \lstinline{f}.

Ainsi, si nous appliquons \lstinline{first} à \lstinline{genRanking}, nous obtenons
un type de sortie compatible au type d'entrée de \lstinline{stabilize} :
\begin{lstlisting}
genRanking :: Node (Ticket, Ranking) Ranking
first genRanking :: Node ((Ticket, Ranking), a) (Ranking, a)
stabilize :: Node (a, Int) (Maybe a, Int)
\end{lstlisting}

Nous combinons ensuite ces noeuds pour n'en avoir qu'un seul, via la fonction
de composition \lstinline{>>>} :
\begin{lstlisting}
stabilizedRanking :: Node ((Ticket, Ranking), Int) (Maybe Ranking, Int)
stabilizedRanking = first genRanking >>> stabilize
\end{lstlisting}

Cette implantation pose problème car elle ne permet pas de construire un classement
complet. \lstinline{genRanking} voit sa sortie non-conservée si \lstinline{stabilize}
produit \lstinline{(Nothing, _)}.
\lstinline{genRanking} est donc limité par \lstinline{stabilize}.


Nous devons donc ajouter une \lstinline{Monad} \lstinline{State} pour conserver l'état d'un exécution à l'autre.
Nous obtenons un \emph{Kielsi Arrow}~\cite{Hughes00}.
\lstinline{Node} devient alors inutile puisque \lstinline{Kleisli} implante déjà les
\emph{typeclass} \Arr et \lstinline{Monad}.

% La différence entre les \Arrs et les \lstinline{Monad}s est que nous pouvons
% uniquement manipuler le type de sortie d'une \lstinline{Monad} alors que nous pouvons
% manipuler le type d'entrées et le type de sortie d'un \Arrp
% C'est ce qui les rend plus composable que les \lstinline{Monad}s.

% Les \Arrs~\cite{Hughes00} sont une généralisation des \lstinline{Monad}s~\cite{Wadler90}.
% Les \lstinline{Monad}s sont définies en Haskell via le \emph{typeclass} suivant :
% \begin{lstlisting}
% class Monad (m :: * -> *) where
%   (>>=) :: m a -> (a -> m b) -> m b
%   (>>) :: m a -> m b -> m b
%   return :: a -> m a
%   fail :: String -> m a
% \end{lstlisting}

% Ici on se place dans le cas d'un type de données \lstinline{m} avec un paramètre
% \lstinline{m :: * -> *}.

% Par exemple la fonction \lstinline{return} va attendre un paramètre de type quelconque
% \lstinline{a} et va l'encapsuler, transmettre cette valeur à un constructeur, dans
% un type de donnée \lstinline{m} paramétré par le type de la valeur de son argument
% \lstinline{a}, il aura donc pour type de retour \lstinline{m a}.

% L'opérateur, un fonction n'ayant pas de caractères alphabétiques, important ici
% est \lstinline{>>=}, il est entouré de paranthèses pour indiquer qu'il est en
% position de préfixe.
% Il va attendre une valeur de type \lstinline{a} dans un contexte \lstinline{m}, soit
% le type \lstinline{m a}, puis une fonction ayant un paramètre de type \lstinline{a}
% et renvoyant une valeur de type \lstinline{b} encapsulé dans le même contexte \lstinline{m}
% que le premier arguement de l'opérateur, la fonction attendue va donc retourner
% une valeur de type \lstinline{m b}. L'opérateur va ensuite retourner une valeur de
% type \lstinline{m b}.
% L'implantation triviale est de renvoyer le retour de la fonction attendue à
% laquelle on a transmis la valeur de type \lstinline{a} désencapsulé de son contexte
% \lstinline{m a}.

% Par exemple prenons le type de données \lstinline{Maybe} :
% \begin{lstlisting}
% data Maybe a = Nothing | Just a
% \end{lstlisting}

% \lstinline{Maybe} est un type paramétrique.
% \lstinline{Maybe} possède deux constructeur : \lstinline{Nothing}, qui n'attends pas
% de valeur et \lstinline{Just} qui attends une valeur de type \lstinline{a}, \lstinline{a}
% pouvant être de n'importe quel type.
% Ainsi \lstinline{Nothing} et \lstinline{Just 1} auront le même type \lstinline{Maybe Int}.
% Mais \lstinline{Just 1} et \lstinline{Just 'a'} auront un type différent, respectivement
% \lstinline{Maybe Int} et \lstinline{Maybe Char}.

% Il nous faut ensuite définir l'instance \lstinline{Maybe} du \emph{typeclass}
% \lstinline{Monad} :
% \begin{lstlisting}
% instance Monad Maybe where
%     Just x  >>= f = f x
%     Nothing >>= _ = Nothing

%     return x = Just x

%     a >> b = a >>= \_ -> b

%     fail _ = Nothing
% \end{lstlisting}

% Les lignes 2 et 3 définissent le corps de \lstinline{>>=}.
% La ligne 2 se lit : pour le constructeur \lstinline{Just} contenant une valeur
% \lstinline{x} et un second paramètre f, la valeur de retour sera la valeur de retour
% de la fonction \lstinline{f} à laquelle \lstinline{x} lui aura été appliqués.
% La ligne 3 se lit : pour le constructeur \lstinline{Nothing}, je ne tiens pas compte
% de mon second argument \lstinline{\_} et je renvoie \lstinline{Nothing}.

% La ligne 5 prend une valeur et la passe au constructeur \lstinline{Just} que je revoie.

% La ligne 7 va appeler \lstinline{>>=} en lui passant son premier paramètre puis en créant
% une fonction anonyme, appelée \emph{lambda expression}, via \lstinline{\textbackslash\_ ->} qui
% va ignorer son paramètre d'entrée et renvoyer le second paramètre de \lstinline{>>}.

% La ligne 9 définit \lstinline{fail} qui va ignorer son paramètre et renvoyer \lstinline{Nothing}.

% Prenons l'exemple de cette fonction qui pour un entier donné, l'incrémente jusqu'à
% 3 puis renvoie \lstinline{Nothing}.
% \begin{lstlisting}
% addUntil3 :: Int -> Maybe Int
% addUntil3 x = if x < 3
%               then Just (x + 1)
%               else Nothing
% \end{lstlisting}

% Notre objectif est de pouvoir chaîner les appels à cette fonction.
% Si nous faisons \lstinline{addUntil3 1} nous obtenons \lstinline{Just 2} du type \lstinline{Maybe Int}.
% Impossible alors d'appeler directement la fonction sur ce résultat.
% Nous sommes obligés de sortir \lstinline{2} de son contexte.
% C'est le rôle de \lstinline{>>=}.
% Ainsi, \lstinline{addUntil3 1 >>= addUntil3} renverra \lstinline{Just 3}.
% De plus, si nous l'appliquons encore, elle renverra toujours \lstinline{Nothing},
% sans que \lstinline{addUntil3} soit évaluée.

% Nous pouvons réécrire \lstinline{addUntil3' 1 >>= addUntil3} en \lstinline{Just 1 >>= addUntil3 >>= addUntil3}
% puisque \lstinline{>>=} va extraire \lstinline{1} de \lstinline{Just}.

% Si nous regardons l'implantation de l'interface, \lstinline{Just 1 >>= addUntil3 >>= addUntil3}
% est équivalent à \lstinline{return 1 >>= addUntil3 >>= addUntil3} et \lstinline{addUntil3}
% peut être réécrit de cette manière :
% \begin{lstlisting}
% addUntil3' :: (Monad m) => Int -> m Int
% addUntil3' x = if x < 3
%                 then return (x + 1)
%                 else fail "too big"
% \end{lstlisting}

% Comme nous le voyons dans la signature \lstinline{addUntil3'} n'est plus liée au type
% de donnée \lstinline{Maybe}, à n'importe quelle type de données implantant le \emph{typeclass}
% \lstinline{Monad}.


\begin{lstlisting}
import Control.Arrow
import Control.Category
import Data.List (sortBy)
import Data.Function (on)
import Data.Maybe (catMaybes)
import Prelude hiding (id,(.))
import Control.Monad.State

type Ticket = String
data Rank = Rank { title :: String, visitors :: Int } deriving (Show, Eq)
type Ranking = [Rank]

genRanking :: Kleisli (State Ranking) Ticket Ranking
genRanking = Kleisli $ \t -> get >>= put . updateRanking t >> get

updateRanking :: Ticket -> Ranking -> Ranking
updateRanking t r = case b of
                        []          -> a ++ [Rank t 1]
                        (x : xs)    -> sortBy (flip compare `on` visitors) (Rank t (1 + visitors x) : a ++ xs)
    where (a, b) = break (\(Rank i _) -> i == t) r

stabilize :: Kleisli (State Int) a (Maybe a)
stabilize = Kleisli $ \e -> get >>= \i ->  if i < 2
                                            then put (i + 1) >> return Nothing
                                            else put 0 >> return (Just e)
\end{lstlisting}

La composition ne peux plus se faire selon les fonctions classiques comme \lstinline{>>>}
puisque les contextes, ici \lstinline{Kleisli (State Ranking)} et \lstinline{Kleisli (State Int)},
sont différents.

\begin{lstlisting}
stabilizedRanking :: Kleisli (State (Ranking, Int)) Ticket (Maybe Ranking)
stabilizedRanking = Kleisli stabilizedRanking'

stabilizedRanking' :: Ticket -> State (Ranking, Int) (Maybe Ranking)
stabilizedRanking' e = do
    (ir, is) <- get
    let (rv, rs) = runState (runKleisli genRanking e) ir
    let (sv, ss) = runState (runKleisli stabilize rv) is
    put (rs, ss)
    return sv
\end{lstlisting}

Cette composition est coûteuse car nous devons définir nous-même la sémantique
d'évaluation qui n'est pas propre à ces deux noeuds en particulier.
Ce qui entraine une forte duplication qui ne va faire que s'accroitre de
composition en composition.
Le mécanisme ne passe pas à l'échelle puisque le tuple sera de plus en plus
grand en fonction des composition.

Ce mécanisme est adhoc est non pérein.

\begin{lstlisting}
\end{lstlisting}

\paragraph{Comonad}
Comonad~\cite{Brookes91}~\cite{Coutts07}

\subsubsection{Modélisation avec du rythme}

\subsection{Introduction des \SAs}

\section{Conclusion}

%The bibliography, done here without a bib file
%This is the old BibTeX style for use with llncs.cls
% \bibliographystyle{splncs}

% %Alternative bibliography styles:
% %the following does the same as above except with alphabetic sorting
% \bibliographystyle{splncs_srt}
% %the following is the current LNCS BibTex with alphabetic sorting
\bibliographystyle{splncs03}
% %If you want to use a different BibTex style include [oribibl] in the document class line

% \begin{thebibliography}{1}
% %add each reference in here like this:
% \bibitem[Kahn74]{Kahn74}
% Gilles Kahn:
% The Semantics of Simple Language for Parallel Programming.
% IFIP Congress, (1974) 471-475.
% \end{thebibliography}
\bibliography{LLNCStmpl}

\end{document}

