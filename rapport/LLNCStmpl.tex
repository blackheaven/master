% LLNCStmpl.tex
% Template file to use for LLNCS papers prepared in LaTeX
%websites for more information: http://www.springer.com
%http://www.springer.com/lncs

\documentclass{llncs}
\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\lstset{
  basicstyle=\small\ttfamily,
  frame=lrtb,
  numbers=left,
  breaklines=true,
  breakatwhitespace=true,
  language=haskell
}
%Use this line instead if you want to use running heads (i.e. headers on each page):
%\documentclass[runningheads]{llncs}

\newcommand{\DF}{\emph{Data-Flow} }
\newcommand{\DFc}{\emph{Data-Flow}}
\newcommand{\DFp}{\emph{Data-Flow}. }
\newcommand{\SA}{\emph{Heterogeneous-Arrow} }
\newcommand{\SAs}{\emph{Heterogeneous-Arrow}s }
\newcommand{\FB}{\emph{Flow-based programming} }
\newcommand{\RP}{\emph{Reactive-based programming} }
\newcommand{\FRP}{\emph{Functional reactive programming} }
\newcommand{\Arr}{\lstinline{Arrow} }
\newcommand{\Arrp}{\lstinline{Arrow}. }
\newcommand{\Arrs}{\lstinline{Arrow}s }


\begin{document}
\title{\SA : modéliser le rythme du \DF}

%If you're using runningheads you can add an abreviated title for the running head on odd pages using the following
%\titlerunning{abreviated title goes here}
%and an alternative title for the table of contents:
%\toctitle{table of contents title}

\subtitle{Modélisation du rythme de traitement et du changement de structure des flux dans un contexte \DF}

%For a single author
%\author{Author Name}

%For multiple authors:
\author{Gautier DI FOLCO}


%If using runnningheads you can abbreviate the author name on even pages:
%\authorrunning{abbreviated author name}
%and you can change the author name in the table of contents
%\tocauthor{enhanced author name}

%For a single institute
%\institute{Institute Name \email{email address}}

% If authors are from different institutes 
\institute{INRIA, équipe DICE, \email{gdifolco@ens-lyon.fr}}

%to remove your email just remove '\email{email address}'
% you can also remove the thanks footnote by removing '\thanks{Thank you to...}'


\maketitle

\begin{abstract}
Le \DF est un outil de programmation permettant d'exprimer des flux de
données circulant entre des entités d'exécutions.

Après avoir présenté ses usages et ses enjeux, nous montrons, à l'aide d'un
cas pratique, une faiblesse dans le modèle actuel qui réside dans la difficulté
de composer des contextes de calculs différents.
Nous fournissons une généralisation des \Arrs en Haskell.
\end{abstract}

\section{Introduction}
Le \DF modélise le "continu" dans les programmes informatiques.
Ce qui permet par exemple de décrire des animations graphiques sous l'aspect de
formules mathématiques sans gérer la manière dont elles seront interprêtées.
Les formules étant exprimées selon des variables continues, elle seront ensuite
discrétisées pour le rendu visuel de manière automatiquement.
Du fait que le continu est représenté par une infinité de valeur entre deux bornes,
il en découle une notion d'infini, les bornes étant inacessibles.
Ce qui force le calcul sur des données incomplètes entrainant des calculs partiels.

Cette notion d'incomplétude des données est utilisé pour répondre à un problème
de charge de traitements.
Par exemple l'afflux de données provenant de l'Iternet a tellement augmenté qu'il
devient trop coûteux en ressources de lancer un calcul donné sur l'ensemble des
données.
De plus, lorsqu'on modélise un flux, il est déjà existant, donc nous n'avons pas
accès au début et le flux n'a pas de fin.
Ainsi des calculs partiels sont effectués et complétés au fur et à mesure de la
réception de nouvelles données.

Notre objectif est de proposer des outils pour manipuler des flux ayant des
rythmes et des structures différents explicitement modélisés.

\section{Historique}
Nous exposons l'historique des langages \DF afin
de mettre en avant l'importance du rythme dans les systèmes \DFp

Strachey~\cite{Strachey73} décrit l'état du monde de la programmation
informatique, en opposant deux paradigmes : la programmation fonctionnelle et impérative.

L'une des premières implantation du \DFc~\cite{Dennis72} réalisée
est présentée comme une généralisation de LISP, qui est un langage fonctionnel.

Le \DF est défini par Dennis et al.~\cite{Dennis72} comme un modèle dont l'exécution
est déclenchée par la disponibilité des données.
Il y a une dépendance explicitement modélisée du code vis-à-vis des données.

\subsection{Réseaux de Kahn}
Kahn~\cite{Kahn74} fournit un langage pour effectuer des calculs en parallèle,
où les programmes sont découpés en entités communiquant entre elles via des
\emph{channel}s, qui sont des listes \emph{FIFO} infinies ayant une taille de
tampon fixe.

\subsection{Prémisses de la modélisation du continu avec le \FB}
Lucid~\cite{AshcroftW76} modélise l'infini en se basant sur les suites mathématiques.
L'infini est modélisé par une valeur de départ et un code pour calculer les valeurs
suivantes.

Une notion de temps a été ajoutée au flux par Esterel~\cite{Berry84}.
Les programmes sont proches des filtres UNIX : ils n'ont qu'une entrée auxquels
ils réagissent sur leur sortie.

Les flux sont considérés comme un ensemble et plus comme un flux unique dans Signal~\cite{Benveniste85}.
Ce qui permet, comme dans StreamIT~\cite{Thies02}, de mettre en relation des flux
pour en créer de nouveaux.

Les programmes sont des graphes acycliques orientés, où les noeuds représentent des
algorithmes élémentaires et les arcs les dépendances sur les données, comme dans
Lustre~\cite{Caspi87}.

\subsection{L'avènement des environnements interactifs avec le \RP}
TBAG~\cite{Elliott94} introduit la notion de variation temporelle.
De manière graphique l'utilisateur va définir un ensemble de relations
entre les objects qui vont varier au cours du temps.
TBAG se charge d'évaluer ces relations pour des valeurs temporelles
significatives afin que l'animation semble avoir été calculée depuis
un flux continu.

Par la suite, MediaFlow~\cite{Elliott95} va permettre la combinaison visuelle
de flux continus.

\emph{Functional Reactive Animation} (Fran)~\cite{Elliott97}~\cite{Elliott98}
s'appuie sur une spécification programmatique des relations entre des objets
en fonction du temps.
Il effectue ensuite son rendu graphique dynamiquement.

Fran est le point de départ de nombreux papiers comme RT-FRP~\cite{Wan02}
qui ajoute un aspect temps-réel où Nilsson et al.\cite{Nilsson2002a} qui se base
sur la déclaration de l'enchaînement des traitements.

Le \FRP considère, comme dans André~\cite{Andre96}, les programmes comme
une réaction à un ensemble de signaux. Un signal perçu déclenche l'exécution
d'un comportement, le programme réagit à un principe de stimuli.

\subsection{Conclusion}
La hausse du volume de données générées, échangées, traitées et stockées augmente de
plus en plus.

Notre hypothèse est que les moyens de traitement et de stockage ne sont plus
suffisants.

Nous devons mettre en place des mécanismes pour permettre de diminuer la charge
de traitements à effectuer.

Le choix que nous avons fait est de considérer que l'information n'est pas complète.
Nous n'en possèdons pas la fin, et nous ne possédons pas souvent le début.

Ainsi, nos calculs sont effectués sur une information incomplète, ce qui nous
donne un calcul partiel.
Lorsque nous avons une nouvelle information, nous reprenons le résultat
précédemment calculé pour le compléter avec la nouvelle donnée.

Il y a une diminution du nombre de calculs, puisque ceux-ci ne sont effectués
que partiellement.

\subsubsection{Rythme et nature du flux}
Nous appelons nature d'un flux la méthode de construction des données sortantes.
Par exemple, le fait d'aggréger les informations d'un flux à un autre va changer
sa nature car nous obtenons une donnée qui va dépendre de son historique
à partir d'une donnée unitaire.

Le rythme est modifié si, par exemple, le calcul est lancé uniquement toutes les
N nouvelles données, le flux de sortie aura N fois moins de messages que le flux d'entrée.

\section{Modélisation du rythme et de la structure des flux}
\subsection{Cas pratique : box office}
Nous disposons d'un flux de tickets de cinéma.
Un ticket est identifié par un nom de film.

Nous souhaitons avoir un premier flux contenant une liste des films ordonnés par
nombre d'entrées décroissant.
Ce qui implique un changement de nature du flux.
Le rythme du flux ne change pas puisque la liste est mise à jour à chaque nouveau
ticket.

À partir de ce flux, nous voulons limiter le débit en le divisant par 100 pour
que la donnée puisse être affichée de manière stable.
Nous opérons un changement de rythme.

\subsection{Mise en oeuvre avec Haskell}
Haskell~\cite{Haskell10} est un langage purement fonctionnel non-strict.

Nous l'avons choisi car il est le support de nombreuses approches à la fois \RP
et en \FRP et qu'il dispose d'un système de types assez avancé pour modéliser
notre domaine d'étude.

\subsubsection{Modélisation sans notion de rythme}
\paragraph{\Arrs}
La méthode classique pour gérer le \DF en Haskell sont les \emph{Arrows}.

Les \Arrs~\cite{Hughes00} sont une spécialisation des \lstinline{Category}
qui définissent la notion de composition sous forme de \emph{typeclass}.

En Haskell un \emph{typeclass} représente une capacité à appeler un ensemble
de fonctions sur un ensemble de type de données.
Il s'agit d'un mécanisme proche des \emph{template}s spécialisées du C++.

\begin{lstlisting}
class Category cat where
  id :: cat a a
  (.) :: cat b c -> cat a b -> cat a c
\end{lstlisting}

Ici nous déclarons le \emph{typeclass} \lstinline{Category}.
Pour un type arbitraire \lstinline{cat}, deux fonctions lui sont associées.
Seul leur type sont déclarés ici, par leurs implantations.

La fonction \lstinline{id}, qui va représenter l'identité, c'est à dire
que  \lstinline{cat} aura ses deux paramètre de même type, le type \lstinline{a}.

L'opérateur de composition \lstinline{(.)} qui va créer une \lstinline{Category}
ayant pour types paramétriques \lstinline{a c} en rediregeant la d'une \lstinline{Category}
\lstinline{b c} vers l'entrée d'une \lstinline{Category} \lstinline{a b}.

On distingue deux types de fonction en Haskell : les fonctions classiques et les opérateurs.
Les fonctions ckassiques sont nommées avec des caractères alphanumériques et commencent
toujours par une minuscule.
Les opérateurs ne sont composés que de caractères non-alphanumériques.

La différence entre les deux est visible au niveau de la position par défaut lors
de l'appel.
Les fonctions classiques ont une position préfixe :
\begin{lstlisting}
add 4 5
\end{lstlisting}

ici, \lstinline{add} est une fonction classique, elle est donc placé devant ses
arguments.

Les opérateurs ont une position infixe :
\begin{lstlisting}
4 + 5
\end{lstlisting}

ici, \lstinline{+} est un opérateur, il est donc placé entre ses deux premiers
arguments.

Nous pouvons changer la position des fonctions classiques et des opérateurs en
les entourant, respectivement, de \emph{back-quotes} (\lstinline{`}) et de paranthèses.
Ainsi, voici l'équivalent des deux exemples précédents en inversant les positions :
\begin{lstlisting}
4 `add` 5
(+) 4 5
\end{lstlisting}

Cette distinction est importante car, lorsque nous mentionnons une fonction en position
préfixe et que nous omettons un ou plusieurs de ses dernier arguments, une fonction
est automatiquement créée.
Cette fonction aura pour paramètres, les paramètres omis.
On parle de currification ou \emph{currying} ou d'application partielle.
De manière plus général, en Haskell, toutes les fonctions n'attendent qu'un argument
et ne renvoie qu'une valeur.
Ainsi, conceptuellement, losqu'une fonction attends plusieurs arguments, lors de
chacun de ses appels, une nouvelle fonction est retournée :
\begin{lstlisting}
add :: Int -> Int -> Int
add 4 :: Int -> Int
add 4 5 :: Int
\end{lstlisting}

Le type de \lstinline{add} peut être ré-écrit de la manière suivante :
\begin{lstlisting}
add :: Int -> (Int -> Int)
\end{lstlisting}

Alors que les fonctions en position préfixes créent automatiquement des fonctions
lorsqu'elles ne sont que partiellement appliquées, si un des deux premiers arguments
manquent à un opérateur, une erreur de syntaxe est levée.
Les exemples suivants ne sont pas syntaxiquement valide :
\begin{lstlisting}
`add`
`add` 5
4 `add`
+
+ 5
4 +
\end{lstlisting}

Pour les rendres valide, il faut les entourer de paranthèses :
\begin{lstlisting}
(`add`)
(`add` 5)
(4 `add`)
(+)
(+ 5)
(4 +)
\end{lstlisting}

C'est la raison pour laquelle, lorsque l'on déclare le type d'un opérateur, comme
l'opérateur de composition \lstinline{(.)}, nous sommes obligés de le paranthèsés,
puisque nous ne lui passons aucune valeur.

Un exemple d'implantation de \lstinline{Category} est pour le type des fonctions.
Le type fonction est un type à part entère noté \lstinline{(->)}.
Ainsi, à partir de la déclaration du \emph{typeclass} \lstinline{Category}, nous
remplaçons toutes les occurences de \lstinline{cat} par \lstinline{(->)}.
\begin{lstlisting}
instance Category (->) where
-- Version prefixe : id :: (->) a a
  id :: a -> a
  id x = x

-- Version prefixe : (.) :: (->) b c -> (->) a b -> (->) a c
  (.) :: (b -> c) -> (a -> b) -> (a -> c)
  f . g = \x -> f (g x)
\end{lstlisting}

\lstinline{id}, ligne 4, attent un argument \lstinline{x} et le retourner.
Le type de \lstinline{x} est quelconque, noté \lstinline{a}, et le type de retour
de \lstinline{id} est le même que le type de son paramètre, soit \lstinline{a}.

\lstinline{(.)}, ligne 8, attent deux fonctions pour en produire une troisième.
Son premier argument, \lstinline{f}, est une fonction attendant un type quelconque
noté \lstinline{b} et renvoyant un type quelconque \lstinline{c}, le tout est
noté \lstinline{b -> c}.
Son second argument, \lstinline{g}, est une fonction attendant un type quelconque
noté \lstinline{a} et renvoyant un type quelconque \lstinline{b}, le tout est
noté \lstinline{a -> b}.
\lstinline{(.)} crée une \emph{lambda expression}, une sorte de fonction anonyme,
via \lstinline{\x ->} attendant un paramètre \lstinline{x}.
Il va appliquer ce paramètre à la fonction \lstinline{g}, via \lstinline{g x}.
Puis le résultat de cette application sera appliqué à la fonction \lstinline{f}.
Par conséquent, la fonction résultante aura un paramètre du type de celui de la
fonction \lstinline{g}, ie. \lstinline{a}, et un type de retour de sa fonction \lstinline{f},
ie. \lstinline{c}.
Donc, c'est une fonction qui prend deux fonctions, l'un prenant un \lstinline{a}
et renvoyant un \lstinline{b}, l'autre prenant un \lstinline{b} et renvoyant un \lstinline{c}.
Elle renvoie une fonction prenant un \lstinline{a} et renvoyant un \lstinline{c},
qui est bien la notion de composition.

Par exemple, si nous disposons de deux fonctions \lstinline{add3} et \lstinline{prod2},
qui, respectivement, ajoute \lstinline{3} à un nombre et le multiplie par \lstinline{2},
nous pouvons les combiner de la manière suivante :
\begin{lstlisting}
add3 :: Int -> Int
add3 x = x + 3

prod2 :: Int -> Int
prod2 x = x * 2

prod2Add3 :: Int -> Int
prod2Add3 = add3 . prod2
\end{lstlisting}

Ainsi \lstinline{prod2Add3 1} renvoie \lstinline{5}.
Nous aurions put l'ecrire \lstinline{prod2Add3 x = prod2 (add3 x)}.
En fait il se passe le mécanisme de substitution suivant :
\begin{lstlisting}
prod2Add3 = add3 . prod2
-- f . g = \x -> f (g x)
-- f est remplace par add3 et g par prod2
prod2Add3 = \x -> add3 (prod2 x)
-- lorsque 1 est applique a prod2Add3 :
prod2Add3 1
(\x -> add3 (prod2 x)) 1
-- x est remplace par 1
add3 (prod2 1)
add3 (1 * 2)
add3 2
2 + 3
5
\end{lstlisting}

La composition se fait via :
\begin{lstlisting}
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
\end{lstlisting}

\lstinline{<<<} est un alias de l'opérateur de composition \lstinline{(.)}.
\lstinline{>>>} est aussi un alias mais dont les paramètres ont été inversés.

Les \Arrs permettent de faire de la manipulation et de la composition de calculs.
Ils représentent la possibilité pour un calcul, comme une fonction, contenu dans un
type de données avec deux types paramétriques, son type d'entrées et son type de sortie,
à être composé avec d'autres calculs du même contexte.

La différence entre les \Arrs et les \lstinline{Monad}s est que nous pouvons
uniquement manipuler le type de sortie d'une \lstinline{Monad} alors que nous pouvons
manipuler le type d'entrées et le type de sortie d'un \Arrp
C'est ce qui les rend plus composable que les \lstinline{Monad}s.

Les \Arrs sont définis en Haskell via le \emph{typeclass} suivant :
\begin{lstlisting}
class Category a => Arrow a where
    arr :: (b -> c) -> a b c
    first :: a b c -> a (b, d) (c, d)
    second :: a b c -> a (d, b) (d, c)
    (***) :: a b c -> a b' c' -> a (b, b') (c, c')
    (&&&) :: a b c -> a b c' -> a b (c, c')
\end{lstlisting}

On voit ici que \Arr est définit en fonction de \lstinline{Category} et non pas
de \lstinline{Monad}, car \lstinline{Category} définit les relations de compositions entre
les types de données, comme les fonctions.

Ici la fonction \lstinline{arr} va construire un contexte \lstinline{a b c} à partir d'une
fonction \lstinline{b -> c}.
Typiquement il s'agit de stocker la fonction dans un type de données.

\lstinline{first} et \lstinline{second} vont changer le type d'entrée et de sortie
en tuple ayant un type supplémentaire dont la valeur sera simplement recopiée
lors de l'évaluation du calcul, respectivement en seconde et en première position
d'un tuple.

\lstinline{***} va aggréger deux calculs qui seront effectués sans interaction l'un
avec l'autre.

\lstinline{&&&} va créer un calcul qui appliquera un même argument à deux calculs ayant
le même type d'entrée et retournera ensuite leur résultat respectif dans un tuple.

Nous modélisons la notion de noeud de calcul par un type de données
\lstinline{Node}.
Il contient une fonction transformant un \lstinline{a} en un \lstinline{b} en fonction
de ses types paramétriques.
Nous définissons ensuite les fonctions nécessaires pour que \lstinline{Node} soit
une instance du \emph{typeclass} \Arrp

L'implantation des noeuds \lstinline{genRanking} et \lstinline{stabilize} qui vont,
respectivement, mettre à jour un classement et limiter le débit d'un flux,
se fait de la façon suivante :
\begin{lstlisting}
import Control.Arrow
import Control.Category
import Data.List (sortBy)
import Data.Function (on)
import Data.Maybe (catMaybes)
import Prelude hiding (id,(.))


data Node a b = Node { process :: a -> b }

instance Category Node where
    id = Node id
    (Node g) . (Node f) = Node (g . f)


instance Arrow Node where
    arr = Node
    first (Node f) = Node (\ ~(b, c) -> (f b, c))

type Ticket = String
data Rank = Rank { title :: String, visitors :: Int } deriving (Show, Eq)
type Ranking = [Rank]

genRanking :: Node (Ticket, Ranking) Ranking
genRanking = arr $ uncurry updateRanking

updateRanking :: Ticket -> Ranking -> Ranking
updateRanking t r = case b of
                        []          -> a ++ [Rank t 1]
                        (x : xs)    -> sortBy (flip compare `on` visitors) (Rank t (1 + visitors x) : a ++ xs)
    where (a, b) = break (\(Rank i _) -> i == t) r

stabilize :: Node (a, Int) (Maybe a, Int)
stabilize = arr $ \(x, i) -> if i < 2 then (Nothing, i + 1) else (Just x, 0)
\end{lstlisting}

Nous combinons ensuite ces noeuds pour n'en avoir qu'un seul, via les fonctions
de compositions disponible puisque \lstinline{Node} implante le \emph{typeclass} \Arrp
\begin{lstlisting}
stabilizedRanking :: Node ((Ticket, Ranking), Int) (Maybe Ranking, Int)
stabilizedRanking = first genRanking >>> stabilize
\end{lstlisting}

Cette implantation pose problème car elle ne permet pas de construire un classement
complet. \lstinline{genRanking} voit sa sortie non-conservée si \lstinline{stabilize}
produit \lstinline{(Nothing, \_)}.
\lstinline{genRanking} est donc limité par \lstinline{stabilize}.

Nous devons donc ajouter une \lstinline{Monad} \lstinline{State} pour conserver l'état d'un exécution à l'autre.
Nous obtenons un \emph{Kielsi Arrow}~\cite{Hughes00}.
\lstinline{Node} devient alors inutile puisque \lstinline{Kleisli} implante déjà les
\emph{typeclass} \Arr et \lstinline{Monad}.

% Les \Arrs~\cite{Hughes00} sont une généralisation des \lstinline{Monad}s~\cite{Wadler90}.
% Les \lstinline{Monad}s sont définies en Haskell via le \emph{typeclass} suivant :
% \begin{lstlisting}
% class Monad (m :: * -> *) where
%   (>>=) :: m a -> (a -> m b) -> m b
%   (>>) :: m a -> m b -> m b
%   return :: a -> m a
%   fail :: String -> m a
% \end{lstlisting}

% Ici on se place dans le cas d'un type de données \lstinline{m} avec un paramètre
% \lstinline{m :: * -> *}.

% Par exemple la fonction \lstinline{return} va attendre un paramètre de type quelconque
% \lstinline{a} et va l'encapsuler, transmettre cette valeur à un constructeur, dans
% un type de donnée \lstinline{m} paramétré par le type de la valeur de son argument
% \lstinline{a}, il aura donc pour type de retour \lstinline{m a}.

% L'opérateur, un fonction n'ayant pas de caractères alphabétiques, important ici
% est \lstinline{>>=}, il est entouré de paranthèses pour indiquer qu'il est en
% position de préfixe.
% Il va attendre une valeur de type \lstinline{a} dans un contexte \lstinline{m}, soit
% le type \lstinline{m a}, puis une fonction ayant un paramètre de type \lstinline{a}
% et renvoyant une valeur de type \lstinline{b} encapsulé dans le même contexte \lstinline{m}
% que le premier arguement de l'opérateur, la fonction attendue va donc retourner
% une valeur de type \lstinline{m b}. L'opérateur va ensuite retourner une valeur de
% type \lstinline{m b}.
% L'implantation triviale est de renvoyer le retour de la fonction attendue à
% laquelle on a transmis la valeur de type \lstinline{a} désencapsulé de son contexte
% \lstinline{m a}.

% Par exemple prenons le type de données \lstinline{Maybe} :
% \begin{lstlisting}
% data Maybe a = Nothing | Just a
% \end{lstlisting}

% \lstinline{Maybe} est un type paramétrique.
% \lstinline{Maybe} possède deux constructeur : \lstinline{Nothing}, qui n'attends pas
% de valeur et \lstinline{Just} qui attends une valeur de type \lstinline{a}, \lstinline{a}
% pouvant être de n'importe quel type.
% Ainsi \lstinline{Nothing} et \lstinline{Just 1} auront le même type \lstinline{Maybe Int}.
% Mais \lstinline{Just 1} et \lstinline{Just 'a'} auront un type différent, respectivement
% \lstinline{Maybe Int} et \lstinline{Maybe Char}.

% Il nous faut ensuite définir l'instance \lstinline{Maybe} du \emph{typeclass}
% \lstinline{Monad} :
% \begin{lstlisting}
% instance Monad Maybe where
%     Just x  >>= f = f x
%     Nothing >>= _ = Nothing

%     return x = Just x

%     a >> b = a >>= \_ -> b

%     fail _ = Nothing
% \end{lstlisting}

% Les lignes 2 et 3 définissent le corps de \lstinline{>>=}.
% La ligne 2 se lit : pour le constructeur \lstinline{Just} contenant une valeur
% \lstinline{x} et un second paramètre f, la valeur de retour sera la valeur de retour
% de la fonction \lstinline{f} à laquelle \lstinline{x} lui aura été appliqués.
% La ligne 3 se lit : pour le constructeur \lstinline{Nothing}, je ne tiens pas compte
% de mon second argument \lstinline{\_} et je renvoie \lstinline{Nothing}.

% La ligne 5 prend une valeur et la passe au constructeur \lstinline{Just} que je revoie.

% La ligne 7 va appeler \lstinline{>>=} en lui passant son premier paramètre puis en créant
% une fonction anonyme, appelée \emph{lambda expression}, via \lstinline{\textbackslash\_ ->} qui
% va ignorer son paramètre d'entrée et renvoyer le second paramètre de \lstinline{>>}.

% La ligne 9 définit \lstinline{fail} qui va ignorer son paramètre et renvoyer \lstinline{Nothing}.

% Prenons l'exemple de cette fonction qui pour un entier donné, l'incrémente jusqu'à
% 3 puis renvoie \lstinline{Nothing}.
% \begin{lstlisting}
% addUntil3 :: Int -> Maybe Int
% addUntil3 x = if x < 3
%               then Just (x + 1)
%               else Nothing
% \end{lstlisting}

% Notre objectif est de pouvoir chaîner les appels à cette fonction.
% Si nous faisons \lstinline{addUntil3 1} nous obtenons \lstinline{Just 2} du type \lstinline{Maybe Int}.
% Impossible alors d'appeler directement la fonction sur ce résultat.
% Nous sommes obligés de sortir \lstinline{2} de son contexte.
% C'est le rôle de \lstinline{>>=}.
% Ainsi, \lstinline{addUntil3 1 >>= addUntil3} renverra \lstinline{Just 3}.
% De plus, si nous l'appliquons encore, elle renverra toujours \lstinline{Nothing},
% sans que \lstinline{addUntil3} soit évaluée.

% Nous pouvons réécrire \lstinline{addUntil3' 1 >>= addUntil3} en \lstinline{Just 1 >>= addUntil3 >>= addUntil3}
% puisque \lstinline{>>=} va extraire \lstinline{1} de \lstinline{Just}.

% Si nous regardons l'implantation de l'interface, \lstinline{Just 1 >>= addUntil3 >>= addUntil3}
% est équivalent à \lstinline{return 1 >>= addUntil3 >>= addUntil3} et \lstinline{addUntil3}
% peut être réécrit de cette manière :
% \begin{lstlisting}
% addUntil3' :: (Monad m) => Int -> m Int
% addUntil3' x = if x < 3
%                 then return (x + 1)
%                 else fail "too big"
% \end{lstlisting}

% Comme nous le voyons dans la signature \lstinline{addUntil3'} n'est plus liée au type
% de donnée \lstinline{Maybe}, à n'importe quelle type de données implantant le \emph{typeclass}
% \lstinline{Monad}.


\begin{lstlisting}
import Control.Arrow
import Control.Category
import Data.List (sortBy)
import Data.Function (on)
import Data.Maybe (catMaybes)
import Prelude hiding (id,(.))
import Control.Monad.State

type Ticket = String
data Rank = Rank { title :: String, visitors :: Int } deriving (Show, Eq)
type Ranking = [Rank]

genRanking :: Kleisli (State Ranking) Ticket Ranking
genRanking = Kleisli $ \t -> get >>= put . updateRanking t >> get

updateRanking :: Ticket -> Ranking -> Ranking
updateRanking t r = case b of
                        []          -> a ++ [Rank t 1]
                        (x : xs)    -> sortBy (flip compare `on` visitors) (Rank t (1 + visitors x) : a ++ xs)
    where (a, b) = break (\(Rank i _) -> i == t) r

stabilize :: Kleisli (State Int) a (Maybe a)
stabilize = Kleisli $ \e -> get >>= \i ->  if i < 2
                                            then put (i + 1) >> return Nothing
                                            else put 0 >> return (Just e)
\end{lstlisting}

La composition ne peux plus se faire selon les fonctions classiques comme \lstinline{>>>}
puisque les contextes, ici \lstinline{Kleisli (State Ranking)} et \lstinline{Kleisli (State Int)},
sont différents.

\begin{lstlisting}
stabilizedRanking :: Kleisli (State (Ranking, Int)) Ticket (Maybe Ranking)
stabilizedRanking = Kleisli stabilizedRanking'

stabilizedRanking' :: Ticket -> State (Ranking, Int) (Maybe Ranking)
stabilizedRanking' e = do
    (ir, is) <- get
    let (rv, rs) = runState (runKleisli genRanking e) ir
    let (sv, ss) = runState (runKleisli stabilize rv) is
    put (rs, ss)
    return sv
\end{lstlisting}

Cette composition est coûteuse car nous devons définir nous-même la sémantique
d'évaluation qui n'est pas propre à ces deux noeuds en particulier.
Ce qui entraine une forte duplication qui ne va faire que s'accroitre de
composition en composition.
Le mécanisme ne passe pas à l'échelle puisque le tuple sera de plus en plus
grand en fonction des composition.

Ce mécanisme est adhoc est non pérein.

\begin{lstlisting}
\end{lstlisting}

\paragraph{Comonad}
Comonad~\cite{Brookes91}~\cite{Coutts07}

\subsubsection{Modélisation avec du rythme}

\subsection{Introduction des \SAs}

\section{Conclusion}

%The bibliography, done here without a bib file
%This is the old BibTeX style for use with llncs.cls
% \bibliographystyle{splncs}

% %Alternative bibliography styles:
% %the following does the same as above except with alphabetic sorting
% \bibliographystyle{splncs_srt}
% %the following is the current LNCS BibTex with alphabetic sorting
\bibliographystyle{splncs03}
% %If you want to use a different BibTex style include [oribibl] in the document class line

% \begin{thebibliography}{1}
% %add each reference in here like this:
% \bibitem[Kahn74]{Kahn74}
% Gilles Kahn:
% The Semantics of Simple Language for Parallel Programming.
% IFIP Congress, (1974) 471-475.
% \end{thebibliography}
\bibliography{LLNCStmpl}

\end{document}

