% LLNCStmpl.tex
% Template file to use for LLNCS papers prepared in LaTeX
%websites for more information: http://www.springer.com
%http://www.springer.com/lncs

\documentclass{llncs}
\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
%Use this line instead if you want to use running heads (i.e. headers on each page):
%\documentclass[runningheads]{llncs}

\newcommand{\DF}{\emph{Data-Flow} }
\newcommand{\SA}{\emph{Super-Arrow} }
\newcommand{\SAs}{\emph{Super-Arrow}s }
\newcommand{\FB}{\emph{Flow-based programming} }
\newcommand{\RP}{\emph{Reactive-based programming} }
\newcommand{\FRP}{\emph{Functional reactive programming} }
\newcommand{\Arr}{\emph{Arrow} }
\newcommand{\Arrs}{\emph{Arrow}s }


\begin{document}
\title{\DF : Devenez le \SA du rythme}

%If you're using runningheads you can add an abreviated title for the running head on odd pages using the following
%\titlerunning{abreviated title goes here}
%and an alternative title for the table of contents:
%\toctitle{table of contents title}

\subtitle{Modélisation du rythme de traitement et du changement de structure des flux dans un contexte \DF}

%For a single author
%\author{Author Name}

%For multiple authors:
\author{Gautier DI FOLCO\inst{1}}


%If using runnningheads you can abbreviate the author name on even pages:
%\authorrunning{abbreviated author name}
%and you can change the author name in the table of contents
%\tocauthor{enhanced author name}

%For a single institute
%\institute{Institute Name \email{email address}}

% If authors are from different institutes 
\institute{INRIA \email{gdifolco@ens-lyon.fr}}

%to remove your email just remove '\email{email address}'
% you can also remove the thanks footnote by removing '\thanks{Thank you to...}'


\maketitle

\begin{abstract}
Le \DF est un outil de programmation permettant d'exprimr des flux de
données circulant entre des entités d'exécutions.

Après avoir présenté ses usages et ses enjeux, nous montrons, à l'aide d'un
cas pratique, une faiblesse dans le modèle actuel.

Nous fournissons une généralisation des \Arrs en théorie des catégories pour
renforcer le modèle.
\end{abstract}

\section{Introduction}
Le \DF modélise le "continu" dans les programmes informatiques.

Il est utlisé pour faire des animations de manière à ne se
concentrer que sur les formules mathématiques des formes géométriques affichées.

Récemment, suite à l'explosion du volume de données à traiter, dans l'internet
par exemple, le \DF est devenu un moyen simple de raisonner sur des données
incomplètes, c'est-à-dire, qu'on ne peut avoir en intégralité, dont on ne connait ni le début ni la fin.

Notre objectif est de proposer des outils pour manipuler des flux ayant des
rythmes et des structures différent explicitement modélisés.

\section{Historique}
Strachey~\cite{Strachey73} décrit l'état du monde de la programmation
informatique, en opposant deux paradigmes : la programmation fonctionnelle et impérative.

Dennis et al.~\cite{Dennis72} définissent le \DF comme un modèle dont l'exécution
est déclancher par la disponibilité des données.
Il y a une dépendance du code vis-à-vis des données.

L'une des premières implantation~\cite{Dennis72} est présenté comme une généralisation
de LISP.

\subsection{Réseaux de Kahn}
Kahn~\cite{Kahn74} fournit un langage pour effectuer des calculs en parllèle,
il fait en sorte que les programmes soient articulés autour des données, plutôt que
des traitements.

Chaque partie du programme ne communique avec les autres que via des
\emph{channel}s, qui sont des listes \emph{FIFO} infinies ayant une taille de
tampon fixe.

\subsection{Prémisses de la modélisation du continu avec le \FB}
L'approche mathématiques de Lucid~\cite{AshcroftW76} s'articule
autour de suites générées à partir d'un point défini.

Pour obtenir un langage temps-réel aux exécutions déterministe, Esterel~\cite{Berry84}
s'est basé sur un modèle synchrone.
La notion de temps multiforme est intégré dans sor modèle afin de vérifier à la
compilation si le temps d'exécution attendu sera respecté, lorsque celui-ci est contraint.
Les programmes sont proches des filtres UNIX : ils n'ont qu'une entrée auxquels
ils réagissent sur leur sortie.

Les flux sont géré comme un ensemble à traiter en temps réel dans Signal~\cite{Benveniste85}.
Les programmes sont des graphes acyclique orienté où les noeuds représentent des
algorithmes élémentaires et les arcs les dépendances sur les données.

Lustre~\cite{Caspi87} évalue ses programme sous forme de formules mathématiques
dépendantes du temps et de données calculées en amont.
Les formules sont référentiellement transparente, ce qui est du à une influence
de la programmation fonctionnelle.

MediaFlow~\cite{Elliott95} corrèle visuellement un ensemble de flux continus.

StreamIT~\cite{Thies02} considère un ensemble de flux média auxquels il faut
appliquer un certain nombre de traitements.

\subsection{L'avènement des environnements interactifs avec le \RP}
\cite{Andre96} conçoit les programmes comme une réaction à un ensemble de
signaux. Un signal perçu déclenchera l'exécution d'un comportement, ce qui
fait que le programme va réagir aux stimuli.

TBAG~\cite{Elliott94} introduit la notion de variation temporelle.
De manière graphique l'utilisateur va définir un ensemble de relation
entre les objects qui vont variées au cours du temps.
TBAG se charge d'évaluer ces relations à pour des valeurs temporelle
significative afin que l'animation semble avoir été calculé depuis
un flux continu.

Fran~\cite{Elliott97}~\cite{Elliott98} est l'acronyme de \emph{Functional Reactive Animation}.
Fran s'appuie sur une spécification programmatique des relations entre des objets
et en fonction du temps.
Il effectue ensuite de manière dynamique son rendu graphique.

Fran~\cite{Elliott97} est le point de départ de nombreux papiers comme RT-FRP~\cite{Wan02}
qui ajout une aspect temps-réel ou \cite{Nilsson2002a} qui se base sur la déclaration
de l'enchaînement des traitements.
Fran est la source d'une famille d'approche appelée \FRP en raison de leurs liens
étroits avec la programmation fonctionnelle.

\subsection{Prise d'envol des besoins de traitements et perte de la vision complète des données}
La hausse du volume de données générées, échangées, traitées et stockées augmente de
plus en plus.

Notre hypothèse est que les moyens de traitement et de stockage ne soient plus
suffisant dans un avenir plus ou moins proche.

Nous devons mettre en place des mécanismes pour permettre de diminuer le nombre
de traitements à effectuer.

Le choix que nous avons fait est de considérer que l'information n'est pas complète.
Nous n'en possèdons pas la fin, il n'y a pas de fin, et nous ne possédons pas
nécessairement le début.

Ainsi, nos calculs sont effectués sur une information incomplète, ce qui nous
donne un calcul incomplet ou partiel.
Lorsque nous avons une nouvelle information, nous reprennons le résultat du
précédent calculé pour le compléter avec la nouvelle donnée.

Il y a donc une diminution du nombre de calculs, puisque ceux-ci ne sont effectués
que partiellement.

\subsubsection{Rythme et nature du flux}
Le fait d'aggréger les informations d'un flux à un autre va changer la nature et
le rythme du flux.

La nature change car nous obtenons une donnée qui va dépendre de son historique
à paritr d'une donnée unitaire, par exemple.

Le rythme est modifié si, par exemple, le calcul est lancé uniquement toutes les
N nouvelles données, le flux de sortie aura N fois moins de message que le flux d'entrée.

\section{Modélisation du rythme et de la structure des flux}
\subsection{Cas pratique : box office}
\subsubsection{Modélisation sans notion de rythme}
4,7,8,15 : arrows
24 : comonad
20 : stream fusion

\subsubsection{Modélisation avec de rythme}
\subsection{Mise en oeuvre avec Haskell}
Introduction à Haskell et des arrows/comonad
\subsection{Introduction des \SAs}

\section{Conclusion}

%The bibliography, done here without a bib file
%This is the old BibTeX style for use with llncs.cls
\bibliographystyle{splncs}

% %Alternative bibliography styles:
% %the following does the same as above except with alphabetic sorting
% %\bibliographystyle{splncs_srt}
% %the following is the current LNCS BibTex with alphabetic sorting
% %\bibliographystyle{splncs03}
% %If you want to use a different BibTex style include [oribibl] in the document class line

% \begin{thebibliography}{1}
% %add each reference in here like this:
% \bibitem[Kahn74]{Kahn74}
% Gilles Kahn:
% The Semantics of Simple Language for Parallel Programming.
% IFIP Congress, (1974) 471-475.
% \end{thebibliography}
\bibliography{LLNCStmpl}

\end{document}

