% LLNCStmpl.tex
% Template file to use for LLNCS papers prepared in LaTeX
%websites for more information: http://www.springer.com
%http://www.springer.com/lncs

\documentclass{llncs}
\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\lstset{breaklines=true, breakatwhitespace=true}
%Use this line instead if you want to use running heads (i.e. headers on each page):
%\documentclass[runningheads]{llncs}

\newcommand{\DF}{\emph{Data-Flow} }
\newcommand{\DFc}{\emph{Data-Flow}}
\newcommand{\DFp}{\emph{Data-Flow}. }
\newcommand{\SA}{\emph{Super-Arrow} }
\newcommand{\SAs}{\emph{Super-Arrow}s }
\newcommand{\FB}{\emph{Flow-based programming} }
\newcommand{\RP}{\emph{Reactive-based programming} }
\newcommand{\FRP}{\emph{Functional reactive programming} }
\newcommand{\Arr}{\texttt{Arrow} }
\newcommand{\Arrp}{\texttt{Arrow}. }
\newcommand{\Arrs}{\texttt{Arrow}s }


\begin{document}
\title{\DF : Devenez le \SA du rythme}

%If you're using runningheads you can add an abreviated title for the running head on odd pages using the following
%\titlerunning{abreviated title goes here}
%and an alternative title for the table of contents:
%\toctitle{table of contents title}

\subtitle{Modélisation du rythme de traitement et du changement de structure des flux dans un contexte \DF}

%For a single author
%\author{Author Name}

%For multiple authors:
\author{Gautier DI FOLCO}


%If using runnningheads you can abbreviate the author name on even pages:
%\authorrunning{abbreviated author name}
%and you can change the author name in the table of contents
%\tocauthor{enhanced author name}

%For a single institute
%\institute{Institute Name \email{email address}}

% If authors are from different institutes 
\institute{INRIA, équipe DICE, \email{gdifolco@ens-lyon.fr}}

%to remove your email just remove '\email{email address}'
% you can also remove the thanks footnote by removing '\thanks{Thank you to...}'


\maketitle

\begin{abstract}
Le \DF est un outil de programmation permettant d'exprimer des flux de
données circulant entre des entités d'exécutions.

Après avoir présenté ses usages et ses enjeux, nous montrons, à l'aide d'un
cas pratique, une faiblesse dans le modèle actuel qui réside dans la difficulté
de composer des contextes de calculs différents.
Nous fournissons une généralisation des \Arrs en théorie des catégories pour
renforcer le modèle.
\end{abstract}

\section{Introduction}
Le \DF modélise le "continu" dans les programmes informatiques.
Ce qui permet par exemple de décrire des animations graphiques sous l'aspect de
formules mathématiques sans gérer la manière dont elles seront interprêtées.
Les formules étant exprimées selon des variables continues, elle seront ensuite
discrétisées pour le rendu visuel de manière automatiquement.
Du fait que le continu est représenté par une infinité de valeur entre deux bornes,
il en découle une notion d'infini, les bornes étant inacessibles.
Ce qui force le calcul sur des données incomplètes entrainant des calculs partiels.

Cette notion d'incomplétude des données est utilisé pour répondre à un problème
de charge de traitements.
Par exemple l'afflux de données provenant de l'Iternet a tellement augmenté qu'il
devient trop coûteux en ressources de lancer un calcul donné sur l'ensemble des
données.
De plus, lorsqu'on modélise un flux, il est déjà existant, donc nous n'avons pas
accès au début et le flux n'a pas de fin.
Ainsi des calculs partiels sont effectués et complétés au fur et à mesure de la
réception de nouvelles données.

Notre objectif est de proposer des outils pour manipuler des flux ayant des
rythmes et des structures différents explicitement modélisés.

\section{Historique}
Nous exposons l'historique des langages \DF afin
de mettre en avant l'importance du rythme dans les systèmes \DFp

Strachey~\cite{Strachey73} décrit l'état du monde de la programmation
informatique, en opposant deux paradigmes : la programmation fonctionnelle et impérative.

L'une des premières implantation du \DFc~\cite{Dennis72} réalisée
est présentée comme une généralisation de LISP, qui est un langage fonctionnel.

Le \DF est défini par Dennis et al.~\cite{Dennis72} comme un modèle dont l'exécution
est déclenchée par la disponibilité des données.
Il y a une dépendance explicitement modélisée du code vis-à-vis des données.

\subsection{Réseaux de Kahn}
Kahn~\cite{Kahn74} fournit un langage pour effectuer des calculs en parallèle,
où les programmes sont découpés en entités communiquant entre elles via des
\emph{channel}s, qui sont des listes \emph{FIFO} infinies ayant une taille de
tampon fixe.

\subsection{Prémisses de la modélisation du continu avec le \FB}
Lucid~\cite{AshcroftW76} modélise l'infini en se basant sur les suites mathématiques.
L'infini est modélisé par une valeur de départ et un code pour calculer les valeurs
suivantes.

Une notion de temps a été ajoutée au flux par Esterel~\cite{Berry84}.
Les programmes sont proches des filtres UNIX : ils n'ont qu'une entrée auxquels
ils réagissent sur leur sortie.

Les flux sont considérés comme un ensemble et plus comme un flux unique dans Signal~\cite{Benveniste85}.
Ce qui permet, comme dans StreamIT~\cite{Thies02}, de mettre en relation des flux
pour en créer de nouveaux.

Les programmes sont des graphes acycliques orientés, où les noeuds représentent des
algorithmes élémentaires et les arcs les dépendances sur les données, comme dans
Lustre~\cite{Caspi87}.

\subsection{L'avènement des environnements interactifs avec le \RP}
TBAG~\cite{Elliott94} introduit la notion de variation temporelle.
De manière graphique l'utilisateur va définir un ensemble de relations
entre les objects qui vont varier au cours du temps.
TBAG se charge d'évaluer ces relations pour des valeurs temporelles
significatives afin que l'animation semble avoir été calculée depuis
un flux continu.

Par la suite, MediaFlow~\cite{Elliott95} va permettre la combinaison visuelle
de flux continus.

\emph{Functional Reactive Animation} (Fran)~\cite{Elliott97}~\cite{Elliott98}
s'appuie sur une spécification programmatique des relations entre des objets
en fonction du temps.
Il effectue ensuite son rendu graphique dynamiquement.

Fran est le point de départ de nombreux papiers comme RT-FRP~\cite{Wan02}
qui ajoute un aspect temps-réel où Nilsson et al.\cite{Nilsson2002a} qui se base
sur la déclaration de l'enchaînement des traitements.

Le \FRP considère, comme dans André~\cite{Andre96}, les programmes comme
une réaction à un ensemble de signaux. Un signal perçu déclenche l'exécution
d'un comportement, le programme réagit à un principe de stimuli.

\subsection{Conclusion}
La hausse du volume de données générées, échangées, traitées et stockées augmente de
plus en plus.

Notre hypothèse est que les moyens de traitement et de stockage ne sont plus
suffisants.

Nous devons mettre en place des mécanismes pour permettre de diminuer la charge
de traitements à effectuer.

Le choix que nous avons fait est de considérer que l'information n'est pas complète.
Nous n'en possèdons pas la fin, et nous ne possédons pas souvent le début.

Ainsi, nos calculs sont effectués sur une information incomplète, ce qui nous
donne un calcul partiel.
Lorsque nous avons une nouvelle information, nous reprenons le résultat
précédemment calculé pour le compléter avec la nouvelle donnée.

Il y a une diminution du nombre de calculs, puisque ceux-ci ne sont effectués
que partiellement.

\subsubsection{Rythme et nature du flux}
Nous appelons nature d'un flux la méthode de construction des données sortantes.
Par exemple, le fait d'aggréger les informations d'un flux à un autre va changer
sa nature car nous obtenons une donnée qui va dépendre de son historique
à partir d'une donnée unitaire.

Le rythme est modifié si, par exemple, le calcul est lancé uniquement toutes les
N nouvelles données, le flux de sortie aura N fois moins de messages que le flux d'entrée.

\section{Modélisation du rythme et de la structure des flux}
\subsection{Cas pratique : box office}
Nous disposons d'un flux de tickets de cinéma.
Un ticket est identifié par un nom de film.

Nous souhaitons avoir un premier flux contenant une liste des films ordonnés par
nombre d'entrées décroissant.
Ce qui implique un changement de nature du flux.
Le rythme du flux ne change pas puisque la liste est mise à jour à chaque nouveau
ticket.

À partir de ce flux, nous voulons limiter le débit en le divisant par 100 pour
que la donnée puisse être affichée de manière stable.
Nous opérons un changement de rythme.

\subsection{Mise en oeuvre avec Haskell}
Haskell~\cite{Haskell10} est un langage purement fonctionnel non-strict.

Nous l'avons choisi car il est le support de nombreuses approches à la fois \RP
et en \FRP et qu'il dispose d'un système de types assez avancé pour modéliser
notre domaine d'étude.

\subsubsection{Modélisation sans notion de rythme}
\paragraph{\Arrs}
La méthode classique pour gérer le \DF en Haskell sont les \emph{Arrows}.

Les \Arrs~\cite{Hughes00} sont une généralisation des \texttt{Monad}s~\cite{Wadler90}.

Les \texttt{Monad}s sont définies en Haskell via le \emph{typeclass} suivant :
\begin{lstlisting}[language=haskell]
class Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
\end{lstlisting}

En Haskell un \emph{typeclass} représente une capacité à appeler un ensemble
de fonctions sur un ensemble de type de données.
Il s'agit d'un mécanisme proche des \emph{template}s spécialisées du C++.
Les interfaces JAVA sont similaires mais sont plus éloignées.

Ici on se place dans le cas d'un type de données \texttt{m} avec un paramètre
\texttt{m :: * -> *}.

Par exemple la fonction \texttt{return} va attendre un paramètre de type quelconque
\texttt{a} et va l'encapsuler, transmettre cette valeur à un constructeur, dans
un type de donnée \texttt{m} paramétré par le type de la valeur de son argument
\texttt{a}, il aura donc pour type de retour \texttt{m a}.

L'opérateur, un fonction n'ayant pas de caractères alphabétiques, important ici
est \texttt{>>=}, il est entouré de paranthèses pour indiquer qu'il est en
position de préfixe.
Il va attendre une valeur de type \texttt{a} dans un contexte \texttt{m}, soit
le type \texttt{m a}, puis une fonction ayant un paramètre de type \texttt{a}
et renvoyant une valeur de type \texttt{b} encapsulé dans le même contexte \texttt{m}
que le premier arguement de l'opérateur, la fonction attendue va donc retourner
une valeur de type \texttt{m b}. L'opérateur va ensuite retourner une valeur de
type \texttt{m b}.
L'implantation triviale est de renvoyer le retour de la fonction attendue à
laquelle on a transmis la valeur de type \texttt{a} désencapsulé de son contexte
\texttt{m a}.

Par exemple prenons le type de données \texttt{Maybe} :
\begin{lstlisting}[language=haskell]
data Maybe a = Nothing | Just a
\end{lstlisting}

\texttt{Maybe} est un type paramétrique.
\texttt{Maybe} possède deux constructeur : \texttt{Nothing}, qui n'attends pas
de valeur et \texttt{Just} qui attends une valeur de type \texttt{a}, \texttt{a}
pouvant être de n'importe quel type.
Ainsi \texttt{Nothing} et \texttt{Just 1} auront le même type \texttt{Maybe Int}.
Mais \texttt{Just 1} et \texttt{Just 'a'} auront un type différent, respectivement
\texttt{Maybe Int} et \texttt{Maybe Char}.

Il nous faut ensuite définir l'instance \texttt{Maybe} du \emph{typeclass}
\texttt{Monad} :
\begin{lstlisting}[language=haskell]
instance Monad Maybe where
    Just x  >>= f = f x
    Nothing >>= _ = Nothing

    return x = Just x

    a >> b = a >>= \_ -> b

    fail _ = Nothing
\end{lstlisting}

Les lignes 2 et 3 définissent le corps de $>>=$.
La ligne 2 se lit : pour le constructeur \texttt{Just} contenant une valeur
\texttt{x} et un second paramètre f, la valeur de retour sera la valeur de retour
de la fonction \texttt{f} à laquelle \texttt{x} lui aura été appliqués.
La ligne 3 se lit : pour le constructeur \texttt{Nothing}, je ne tiens pas compte
de mon second argument \texttt{\_} et je renvoie \texttt{Nothing}.

La ligne 5 prend une valeur et la passe au constructeur \texttt{Just} que je revoie.

La ligne 7 va appeler $>>=$ en lui passant son premier paramètre puis en créant
une fonction anonyme, appelée \emph{lambda expression}, via \texttt{\textbackslash\_ ->} qui
va ignorer son paramètre d'entrée et renvoyer le second paramètre de $>>$.

La ligne 9 définit \texttt{fail} qui va ignorer son paramètre et renvoyer \texttt{Nothing}.

Prenons l'exemple de cette fonction qui pour un entier donné, l'incrémente jusqu'à
3 puis renvoie \texttt{Nothing}.
\begin{lstlisting}[language=haskell]
addUntil3 :: Int -> Maybe Int
addUntil3 x = if x < 3
              then Just (x + 1)
              else Nothing
\end{lstlisting}

Notre objectif est de pouvoir chaîner les appels à cette fonction.
Si nous faisons \texttt{addUntil3 1} nous obtenons \texttt{Just 2} du type \texttt{Maybe Int}.
Impossible alors d'appeler directement la fonction sur ce résultat.
Nous sommes obligés de sortir \texttt{2} de son contexte.
C'est le rôle de $>>=$.
Ainsi, \texttt{addUntil3 1 >>= addUntil3} renverra \texttt{Just 3}.
De plus, si nous l'appliquons encore, elle renverra toujours \texttt{Nothing},
sans que \texttt{addUntil3} soit évaluée.

Nous pouvons réécrire \texttt{addUntil3' 1 >>= addUntil3} en \texttt{Just 1 >>= addUntil3 >>= addUntil3}
puisque $>>=$ va extraire \texttt{1} de \texttt{Just}.

Si nous regardons l'implantation de l'interface, \texttt{Just 1 >>= addUntil3 >>= addUntil3}
est équivalent à \texttt{return 1 >>= addUntil3 >>= addUntil3} et \texttt{addUntil3}
peut être réécrit de cette manière :
\begin{lstlisting}[language=haskell]
addUntil3' :: (Monad m) => Int -> m Int
addUntil3' x = if x < 3
                then return (x + 1)
                else fail "too big"
\end{lstlisting}

Comme nous le voyons dans la signature \texttt{addUntil3'} n'est plus liée au type
de donnée \texttt{Maybe}, à n'importe quelle type de données implantant le \emph{typeclass}
\texttt{Monad}.

Les \Arrs permettent de faire de la manipulation et de la composition de calculs.
Ils représentent la possibilité pour un calcul, comme une fonction, contenu dans un
type de données avec deux types paramétriques, son type d'entrées et son type de sortie,
à être composé avec d'autres calculs du même contexte.

La différence entre les \Arrs et les \texttt{Monad}s est que nous pouvons
uniquement manipuler le type de sortie d'une \texttt{Monad} alors que nous pouvons
manipuler le type d'entrées et le type de sortie d'un \Arrp
C'est ce qui les rend plus composable que les \texttt{Monad}s.

Les \Arrs sont définis en Haskell via le \emph{typeclass} suivant :
\begin{lstlisting}[language=haskell]
class Control.Category.Category a => Arrow a where
    arr :: (b -> c) -> a b c
    first :: a b c -> a (b, d) (c, d)
    second :: a b c -> a (d, b) (d, c)
    (***) :: a b c -> a b' c' -> a (b, b') (c, c')
    (&&&) :: a b c -> a b c' -> a b (c, c')
\end{lstlisting}

On voit ici que \Arr est définit en fonction de \texttt{Category} et non pas
de \texttt{Monad}, car \texttt{Category} définit les relations de compositions entre
les types de données, comme les fonctions.

Ici la fonction \texttt{arr} va construire un contexte \texttt{a b c} à partir d'une
fonction \texttt{b -> c}.
Typiquement il s'agit de stocker la fonction dans un type de données.

\texttt{first} et \texttt{second} vont changer le type d'entrée et de sortie
en tuple ayant un type supplémentaire dont la valeur sera simplement recopiée
lors de l'évaluation du calcul, respectivement en seconde et en première position
d'un tuple.

\texttt{***} va aggréger deux calculs qui seront effectués sans interaction l'un
avec l'autre.

\texttt{\&\&\&} va créer un calcul qui appliquera un même argument à deux calculs ayant
le même type d'entrée et retournera ensuite leur résultat respectif dans un tuple.

La composition se fait via :
\begin{lstlisting}[language=haskell]
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
\end{lstlisting}

$>>>$ va créer une nouvelle catégorie ayant pour premier type paramétrique
\texttt{a} et pour second \texttt{c} à partir de deux catégories.
La première ayant un type doublement paramétrique \texttt{a b} et la seconde
\texttt{b c}.

$<<<$ va en faire de même avec ses arguments inversé.
$<<<$ est un alias de l'opérateur de composition \texttt{.} qui, dans le cas
des fonctions aura la forme suivante :
\begin{lstlisting}[language=haskell]
(.) :: (b -> c) -> (a -> b) -> (a -> c)
\end{lstlisting}
Son rôle sera de prendre deux fonctions, le type de sortie \texttt{b} de la seconde
étant le même que le type d'entrée de la première et de créer une nouvelle fonction
appliquant le résultat de la seconde fonction à la première.

Nous modélisons la notion de noeud de calcul par un type de données
\texttt{Node}.
Il contient une fonction transformant un \texttt{a} en un \texttt{b} en fonction
de ses types paramétriques.
Nous définissons ensuite les fonctions nécessaires pour que \texttt{Node} soit
une instance du \emph{typeclass} \Arrp

L'implantation des noeuds \texttt{genRanking} et \texttt{stabilize} qui vont,
respectivement, mettre à jour un classement et limiter le débit d'un flux,
se fait de la façon suivante :
\begin{lstlisting}[language=haskell]
import Control.Arrow
import Control.Category
import Data.List (sortBy)
import Data.Function (on)
import Data.Maybe (catMaybes)
import Prelude hiding (id,(.))


data Node a b = Node { process :: a -> b }

instance Category Node where
    id = Node id
    (Node g) . (Node f) = Node (g . f)


instance Arrow Node where
    arr = Node
    first (Node f) = Node (\ ~(b, c) -> (f b, c))

type Ticket = String
data Rank = Rank { title :: String, visitors :: Int } deriving (Show, Eq)
type Ranking = [Rank]

genRanking :: Node (Ticket, Ranking) Ranking
genRanking = arr $ uncurry updateRanking

updateRanking :: Ticket -> Ranking -> Ranking
updateRanking t r = case b of
                        []          -> a ++ [Rank t 1]
                        (x : xs)    -> sortBy (flip compare `on` visitors) (Rank t (1 + visitors x) : a ++ xs)
    where (a, b) = break (\(Rank i _) -> i == t) r

stabilize :: Node (a, Int) (Maybe a, Int)
stabilize = arr $ \(x, i) -> if i < 2 then (Nothing, i + 1) else (Just x, 0)
\end{lstlisting}

Nous combinons ensuite ces noeuds pour n'en avoir qu'un seul, via les fonctions
de compositions disponible puisque \texttt{Node} implante le \emph{typeclass} \Arrp
\begin{lstlisting}[language=haskell]
stabilizedRanking :: Node ((Ticket, Ranking), Int) (Maybe Ranking, Int)
stabilizedRanking = first genRanking >>> stabilize
\end{lstlisting}

Cette implantation pose problème car elle ne permet pas de construire un classement
complet. \texttt{genRanking} voit sa sortie non-conservée si \texttt{stabilize}
produit \texttt{(Nothing, \_)}.
\texttt{genRanking} est donc limité par \texttt{stabilize}.

Nous devons donc ajouter une \texttt{Monad} \texttt{State} pour conserver l'état d'un exécution à l'autre.
Nous obtenons un \emph{Kielsi Arrow}~\cite{Hughes00}.
\texttt{Node} devient alors inutile puisque \texttt{Kleisli} implante déjà les
\emph{typeclass} \Arr et \texttt{Monad}.


\begin{lstlisting}[language=haskell]
import Control.Arrow
import Control.Category
import Data.List (sortBy)
import Data.Function (on)
import Data.Maybe (catMaybes)
import Prelude hiding (id,(.))
import Control.Monad.State

type Ticket = String
data Rank = Rank { title :: String, visitors :: Int } deriving (Show, Eq)
type Ranking = [Rank]

genRanking :: Kleisli (State Ranking) Ticket Ranking
genRanking = Kleisli $ \t -> get >>= put . updateRanking t >> get

updateRanking :: Ticket -> Ranking -> Ranking
updateRanking t r = case b of
                        []          -> a ++ [Rank t 1]
                        (x : xs)    -> sortBy (flip compare `on` visitors) (Rank t (1 + visitors x) : a ++ xs)
    where (a, b) = break (\(Rank i _) -> i == t) r

stabilize :: Kleisli (State Int) a (Maybe a)
stabilize = Kleisli $ \e -> get >>= \i ->  if i < 2
                                            then put (i + 1) >> return Nothing
                                            else put 0 >> return (Just e)
\end{lstlisting}

La composition ne peux plus se faire selon les fonctions classiques comme $>>>$
puisque les contextes, ici \texttt{Kleisli (State Ranking)} et \texttt{Kleisli (State Int)},
sont différents.

\begin{lstlisting}[language=haskell]
stabilizedRanking :: Kleisli (State (Ranking, Int)) Ticket (Maybe Ranking)
stabilizedRanking = Kleisli stabilizedRanking'

stabilizedRanking' :: Ticket -> State (Ranking, Int) (Maybe Ranking)
stabilizedRanking' e = do
    (ir, is) <- get
    let (rv, rs) = runState (runKleisli genRanking e) ir
    let (sv, ss) = runState (runKleisli stabilize rv) is
    put (rs, ss)
    return sv
\end{lstlisting}

Cette composition est coûteuse car nous devons définir nous-même la sémantique
d'évaluation qui n'est pas propre à ces deux noeuds en particulier.
Ce qui entraine une forte duplication qui ne va faire que s'accroitre de
composition en composition.
Le mécanisme ne passe pas à l'échelle puisque le tuple sera de plus en plus
grand en fonction des composition.

Ce mécanisme est adhoc est non pérein.

\begin{lstlisting}[language=haskell]
\end{lstlisting}

\paragraph{Comonad}
Comonad~\cite{Brookes91}~\cite{Coutts07}

\subsubsection{Modélisation avec du rythme}

\subsection{Introduction des \SAs}

\section{Conclusion}

%The bibliography, done here without a bib file
%This is the old BibTeX style for use with llncs.cls
% \bibliographystyle{splncs}

% %Alternative bibliography styles:
% %the following does the same as above except with alphabetic sorting
% \bibliographystyle{splncs_srt}
% %the following is the current LNCS BibTex with alphabetic sorting
\bibliographystyle{splncs03}
% %If you want to use a different BibTex style include [oribibl] in the document class line

% \begin{thebibliography}{1}
% %add each reference in here like this:
% \bibitem[Kahn74]{Kahn74}
% Gilles Kahn:
% The Semantics of Simple Language for Parallel Programming.
% IFIP Congress, (1974) 471-475.
% \end{thebibliography}
\bibliography{LLNCStmpl}

\end{document}

