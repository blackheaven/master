% LLNCStmpl.tex
% Template file to use for LLNCS papers prepared in LaTeX
%websites for more information: http://www.springer.com
%http://www.springer.com/lncs

\documentclass{llncs}
\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\lstset{breaklines=true, breakatwhitespace=true}
%Use this line instead if you want to use running heads (i.e. headers on each page):
%\documentclass[runningheads]{llncs}

\newcommand{\DF}{\emph{Data-Flow} }
\newcommand{\DFp}{\emph{Data-Flow}. }
\newcommand{\SA}{\emph{Super-Arrow} }
\newcommand{\SAs}{\emph{Super-Arrow}s }
\newcommand{\FB}{\emph{Flow-based programming} }
\newcommand{\RP}{\emph{Reactive-based programming} }
\newcommand{\FRP}{\emph{Functional reactive programming} }
\newcommand{\Arr}{\emph{Arrow} }
\newcommand{\Arrs}{\emph{Arrow}s }


\begin{document}
\title{\DF : Devenez le \SA du rythme}

%If you're using runningheads you can add an abreviated title for the running head on odd pages using the following
%\titlerunning{abreviated title goes here}
%and an alternative title for the table of contents:
%\toctitle{table of contents title}

\subtitle{Modélisation du rythme de traitement et du changement de structure des flux dans un contexte \DF}

%For a single author
%\author{Author Name}

%For multiple authors:
\author{Gautier DI FOLCO}


%If using runnningheads you can abbreviate the author name on even pages:
%\authorrunning{abbreviated author name}
%and you can change the author name in the table of contents
%\tocauthor{enhanced author name}

%For a single institute
%\institute{Institute Name \email{email address}}

% If authors are from different institutes 
\institute{INRIA, équipe DICE, \email{gdifolco@ens-lyon.fr}}

%to remove your email just remove '\email{email address}'
% you can also remove the thanks footnote by removing '\thanks{Thank you to...}'


\maketitle

\begin{abstract}
Le \DF est un outil de programmation permettant d'exprimer des flux de
données circulant entre des entités d'exécutions.

Après avoir présenté ses usages et ses enjeux, nous montrons, à l'aide d'un
cas pratique, une faiblesse dans le modèle actuel.
Nous fournissons une généralisation des \Arrs en théorie des catégories pour
renforcer le modèle.
\end{abstract}

\section{Introduction}
Le \DF modélise le "continu" dans les programmes informatiques.
Ce qui permet de décrire des animations graphiques sous l'aspect de formules mathématiques
sans gérer la manière dont elles seront interprêtées.

Il en découle une notion d'infini ce qui force le calcul sur des données incomplètes
entrainnant des calculs partiel.
L'explosion du volume de données à traiter dans l'Internet est un bon cas pratique
puisque, lorsqu'on modélise un flux, il est déjà existant, donc nous n'avons pas
accès au début et le flux n'a pas de fin. Nous sommes donc obligé de produire
des résultats partielle, ce qui diminu la charge de traitement qui augmente
avec le volume croissant des données produites.

Notre objectif est de proposer des outils pour manipuler des flux ayant des
rythmes et des structures différents explicitement modélisés.

\section{Historique}
Notre but est de mettre en avant l'importance du rythme dans les systèmes \DFp
Pour cela nous exposons l'historique des langages \DF afin de justifier sa
pertinence.

Strachey~\cite{Strachey73} décrit l'état du monde de la programmation
informatique, en opposant deux paradigmes : la programmation fonctionnelle et impérative.

Lorsque l'une des premières implantation du \DF~\cite{Dennis72} est réalisée, elle
est présentée comme une généralisation de LISP, qui est un langage fonctionnel.

Le \DF est définit par Dennis et al.~\cite{Dennis72} définissent le \DF comme un modèle dont l'exécution
est déclencher par la disponibilité des données.
Il y a une dépendance du code vis-à-vis des données.

\subsection{Réseaux de Kahn}
Kahn~\cite{Kahn74} fournit un langage pour effectuer des calculs en parallèle,
il fait en sorte que les programmes sont articulés autour des données, plutôt que
des traitements.

Chaque partie du programme ne communique avec les autres que via des
\emph{channel}s, qui sont des listes \emph{FIFO} infinies ayant une taille de
tampon fixe.

\subsection{Prémisses de la modélisation du continu avec le \FB}
Lucid~\cite{AshcroftW76} modélise l'infini en se basant sur les suites mathématiques.

Une notion de temps a été ajouté au flux par Esterel~\cite{Berry84}.
Les programmes sont proches des filtres UNIX : ils n'ont qu'une entrée auxquels
ils réagissent sur leur sortie.

Les flux sont considéré comme un ensemble et plus comme un flux unique dans Signal~\cite{Benveniste85}.
Ce qui permet, comme dans StreamIT~\cite{Thies02}, le mettre en relation des flux
pour en créer de nouveaux.

Les programmes sont des graphes acyclique orienté où les noeuds représentent des
algorithmes élémentaires et les arcs les dépendances sur les données, comme dans
Lustre~\cite{Caspi87}.

\subsection{L'avènement des environnements interactifs avec le \RP}
TBAG~\cite{Elliott94} introduit la notion de variation temporelle.
De manière graphique l'utilisateur va définir un ensemble de relation
entre les objects qui vont variées au cours du temps.
TBAG se charge d'évaluer ces relations à pour des valeurs temporelle
significative afin que l'animation semble avoir été calculé depuis
un flux continu.

Par la suite, MediaFlow~\cite{Elliott95} va permettre la combinaison visuelle
de flux continus.

\emph{Functional Reactive Animation} (Fran~\cite{Elliott97}~\cite{Elliott98})
s'appuie sur une spécification programmatique des relations entre des objets
et en fonction du temps.
Il effectue ensuite de manière dynamique son rendu graphique.

Fran est le point de départ de nombreux papiers comme RT-FRP~\cite{Wan02}
qui ajoute un aspect temps-réel où Nilsson et al.\cite{Nilsson2002a} se basent
sur la déclaration de l'enchaînement des traitements.

Fran est la source d'une famille d'approches appelée \FRP en raison de leurs liens
étroits avec la programmation fonctionnelle.
Cette famille considère, comme dans André~\cite{Andre96}, les programmes comme
une réaction à un ensemble de signaux. Un signal perçu déclenchera l'exécution
d'un comportement, le programme réagit à un principe de stimuli.

\subsection{Prise d'envol des besoins de traitements et perte de la vision complète des données}
La hausse du volume de données générées, échangées, traitées et stockées augmente de
plus en plus.

Notre hypothèse est que les moyens de traitement et de stockage ne soient plus
suffisant dans un avenir plus ou moins proche.

Nous devons mettre en place des mécanismes pour permettre de diminuer le nombre
de traitements à effectuer.

Le choix que nous avons fait est de considérer que l'information n'est pas complète.
Nous n'en possèdons pas la fin, il n'y a pas de fin, et nous ne possédons pas
souvent le début.

Ainsi, nos calculs sont effectués sur une information incomplète, ce qui nous
donne un calcul incomplet ou partiel.
Lorsque nous avons une nouvelle information, nous reprenons le résultat du
précédent calculé pour le compléter avec la nouvelle donnée.

Il y a une diminution du nombre de calculs, puisque ceux-ci ne sont effectués
que partiellement.

\subsubsection{Rythme et nature du flux}
Le fait d'aggréger les informations d'un flux à un autre va changer la nature et
le rythme du flux.

La nature change car nous obtenons une donnée qui va dépendre de son historique
à paritr d'une donnée unitaire, par exemple.

Le rythme est modifié si, par exemple, le calcul est lancé uniquement toutes les
N nouvelles données, le flux de sortie aura N fois moins de message que le flux d'entrée.

\section{Modélisation du rythme et de la structure des flux}
\subsection{Cas pratique : box office}
Nous disposons d'un flux de tickets de cinéma contenant le nom du film du ticket.

Nous souhaitons avoir un premier flux contenant une liste des films ordonnés par
nombre d'entrées décroissant.
Ce qui implique un changement de nature du flux.
Le rythme du flux ne change pas puisque la liste est mise à jour à chaque nouveau
ticket.

À partir de ce flux, nous voulons limiter le débit en le divisant par 100 pour
que la donnée puisse être affichée de manière stable.
Nous opérons un changement de rythme.

\subsection{Mise en oeuvre avec Haskell}
Haskell~\cite{Haskell10} est un langage purement fonctionnel non-strict.

Nous l'avons choisi car il est le support de nombreuses approches en \RP
et en \FRP et qu'il dispose d'un système de types assez avancé pour modéliser
notre domaine d'étude.

\subsubsection{Modélisation sans notion de rythme}
\paragraph{Arrows}
Les Arrows~\cite{Hughes00} sont une généralisation des Monades~\cite{Wadler90}.
Ils permettent de faire de la manipulation et de la composition de calculs.

Ils sont définit en Haskell via le \emph{typeclass} suivant :
\begin{lstlisting}[language=haskell]
class Control.Category.Category a => Arrow a where
    arr :: (b -> c) -> a b c
    first :: a b c -> a (b, d) (c, d)
    second :: a b c -> a (d, b) (d, c)
    (***) :: a b c -> a b' c' -> a (b, b') (c, c')
    (&&&) :: a b c -> a b c' -> a b (c, c')
\end{lstlisting}

La composition se fait via :
\begin{lstlisting}[language=haskell]
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
\end{lstlisting}

L'implantation des noeuds \emph{genRanking} et \emph{stabilize} qui vont,
respectivement, mettre à jour un classement et limiter le débit d'un flux,
se fait de la façon suivante :
\begin{lstlisting}[language=haskell]
import Control.Arrow
import Control.Category
import Data.List (sortBy)
import Data.Function (on)
import Data.Maybe (catMaybes)
import Prelude hiding (id,(.))


data Node a b = Node { process :: a -> b }

instance Category Node where
    id = Node id
    (Node g) . (Node f) = Node (g . f)


instance Arrow Node where
    arr = Node
    first (Node f) = Node (\ ~(b, c) -> (f b, c))

type Ticket = String
data Rank = Rank { title :: String, visitors :: Int } deriving (Show, Eq)
type Ranking = [Rank]

genRanking :: Node (Ticket, Ranking) Ranking
genRanking = arr $ uncurry updateRanking

updateRanking :: Ticket -> Ranking -> Ranking
updateRanking t r = case b of
                        []          -> a ++ [Rank t 1]
                        (x : xs)    -> sortBy (flip compare `on` visitors) (Rank t (1 + visitors x) : a ++ xs)
    where (a, b) = break (\(Rank i _) -> i == t) r

stabilize :: Node (a, Int) (Maybe a, Int)
stabilize = arr $ \(x, i) -> if i < 2 then (Nothing, i + 1) else (Just x, 0)
\end{lstlisting}

Nous combinons ensuite ces noeuds pour n'en avoir qu'un seul :
\begin{lstlisting}[language=haskell]
stabilizedRanking :: Node ((Ticket, Ranking), Int) (Maybe Ranking, Int)
stabilizedRanking = first genRanking >>> stabilize
\end{lstlisting}

Cette implantation pose problème car elle ne permet pas de construire un classement
complet, puisque \emph{genRanking} voit sa sortie non-conservée si \emph{stabilize}
produit \texttt{(Nothing, \_)}.
\emph{genRanking} est donc limité par \emph{stabilize}.


\paragraph{Comonad}
Comonad~\cite{Brookes91}~\cite{Coutts07}
\paragraph{Stream fusion}
Stream fusion~\cite{Yi05}

\subsubsection{Modélisation avec du rythme}

\subsection{Introduction des \SAs}

\section{Conclusion}

%The bibliography, done here without a bib file
%This is the old BibTeX style for use with llncs.cls
\bibliographystyle{splncs}

% %Alternative bibliography styles:
% %the following does the same as above except with alphabetic sorting
% %\bibliographystyle{splncs_srt}
% %the following is the current LNCS BibTex with alphabetic sorting
% %\bibliographystyle{splncs03}
% %If you want to use a different BibTex style include [oribibl] in the document class line

% \begin{thebibliography}{1}
% %add each reference in here like this:
% \bibitem[Kahn74]{Kahn74}
% Gilles Kahn:
% The Semantics of Simple Language for Parallel Programming.
% IFIP Congress, (1974) 471-475.
% \end{thebibliography}
\bibliography{LLNCStmpl}

\end{document}

