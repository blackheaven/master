\documentclass{article}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage[utf8]{inputenc}
\usepackage[titletoc,toc,title]{appendix}

\title{TWAIN\footnote{Technology Without an Interesting Name} \emph{flow-based programming}}
\author{Gautier DI FOLCO}
\date{2014}

\begin{document}
\maketitle
\tableofcontents

% \section{Abstract}\label{abstract}
\begin{abstract}
L'objectif de ce document est de fournir des pistes sur l'intégration du
\emph{flow-based programming} dans les langages impératifs.
\end{abstract}

\section{Paradigmes de programmation}
\subsection{Impératif}
Spécification séquentielle des calculs à effectuer sur une donnée d'entrée
pour obtenir une donnée en sortie.

\subsection{Fonctionnel}
Spécification de l'ensemble des transformations à effectuer sur des données
d'entrées pour obtenir les données de sortie.

\subsection{\emph{Flow-based programming}}
Spécification de l'enchainement des transformations à partir d'un flux de données
d'entrée pour obtenir une flux de données en sortie.

\section{Constats}
\subsection{\emph{Legacy}}
Aujourd'hui la majorité des programmes existants se reposent sur le paradigme impératif.

Cela implique que d'une part la majorité des développeurs est habituée au paradigme
impératif.
Changer de paradigme requiert un temps d'apprentissage global, c'est-à-dire de
la syntaxe, des concepts et des idiomes, non-négligeable.
À tel point qu'il peut sembler plus rentable de vivre avec les difficultés
d'expressions intrinsèques au paradigme vis-à-vis du problème que l'on tente de
résoudre, que d'apprendre et d'utiliser un paradigme plus adéquat.

Enfin, la masse de code pré-existante, ainsi que les outils disponibles,
est trop importante pour envisager une ré-écriture ou une adaptation
vers ou pour des langages de type \emph{flow-based programming}.

\subsection{Objectifs du \emph{flow-based programming}}
L'un des objectifs du \emph{flow-based programming} est de modéliser la notion de
continuité d'arriver et de production de l'information.

Nous passons d'une vision de l'information complète et finie à une vision partielle
et infinie.

L'information n'existe de manière brute que lors de son passage dans le système.
Sa durée de vie est limité.
Une information, à un cycle de vie : elle nait à l'entrée du système et meurt à sa
sortie, ce qui implique que plus l'information reste dans notre système, plus elle
vieillit et plus elle perd de la valeur.

\section{Choix}
Nous devons insérer cette notion de "non-terminaison" dans le langage afin de
pouvoir modéliser des flux continus d'information.

Nous choisissons d'ajouter une notion d'infini, tout en provoquant le moins de
modifications possible dans les programmes existants, afin que l'intégration à
des programmes existants soit aussi transparente que possible.

\section{Paresse}
Le problème majeur c'est que dans les langages impératifs l'exécution des instructions
se fait au fur et à mesure.
Créer une liste infinie bloquerait l'ensemble du programme sur la construction de
cette liste, sans que le programme puisse s'arrêter.
Pour que celà soit possible, nous devons introduire la notion de paresse.

Ainsi, les éléments d'une liste ne seront calculés que si une instruction tente
d'accéder à un de ses éléments, ou si une boucle tente d'itérer sur cette dernière
via un \emph{iterator}.

De plus, lorsqu'une boucle va itérer sur un flux, celle-ci sera bloqué jusqu'à ce
qu'un élément soit disponible pour être traité.

\end{document}
